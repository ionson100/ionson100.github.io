{"version":3,"file":"static/js/4053.f6f86039.chunk.js","mappings":"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","sources":["../node_modules/ol/interaction/Select.js","../node_modules/ol/geom/Circle.js","../node_modules/ol/interaction/Draw.js","../node_modules/ol/interaction/Modify.js","../node_modules/bsr-osm/dist/esm/index.js"],"sourcesContent":["/**\n * @module ol/interaction/Select\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport Interaction from './Interaction.js';\nimport VectorLayer from '../layer/Vector.js';\nimport {TRUE} from '../functions.js';\nimport {clear} from '../obj.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {extend} from '../array.js';\nimport {getUid} from '../util.js';\nimport {never, shiftKeyOnly, singleClick} from '../events/condition.js';\n\n/**\n * @enum {string}\n */\nconst SelectEventType = {\n  /**\n   * Triggered when feature(s) has been (de)selected.\n   * @event SelectEvent#select\n   * @api\n   */\n  SELECT: 'select',\n};\n\n/**\n * A function that takes a {@link module:ol/Feature~Feature} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @typedef {function(import(\"../Feature.js\").default, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [addCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is the event\n * for the selected features as a whole. By default, this is\n * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that\n * feature and removes any that were in the selection. Clicking outside any\n * feature removes all from the selection.\n * See `toggle`, `add`, `remove` options for adding/removing extra features to/\n * from the selection.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers]\n * A list of layers from which features should be selected. Alternatively, a\n * filter function can be provided. The function will be called for each layer\n * in the map and should return `true` for layers that you want to be\n * selectable. If the option is absent, all visible layers will be considered\n * selectable.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style]\n * Style for the selected features. By default the default edit style is used\n * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply\n * any style changes for selected features.\n * If set to a falsey value, the selected feature's style will not change.\n * @property {import(\"../events/condition.js\").Condition} [removeCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [toggleCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is in addition\n * to the `condition` event. By default,\n * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as\n * well as the `condition` event, adds that feature to the current selection if\n * it is not currently selected, and removes it if it is. See `add` and `remove`\n * if you want to use different events instead of a toggle.\n * @property {boolean} [multi=false] A boolean that determines if the default\n * behaviour should select only single features or all (overlapping) features at\n * the clicked map position. The default of `false` means single select.\n * @property {Collection<Feature>} [features]\n * Collection where the interaction will place selected features. Optional. If\n * not set the interaction will create a collection. In any case the collection\n * used by the interaction is returned by\n * {@link module:ol/interaction/Select~Select#getFeatures}.\n * @property {FilterFunction} [filter] A function\n * that takes a {@link module:ol/Feature~Feature} and a\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside\n * the radius around the given position will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of\n * this type.\n */\nexport class SelectEvent extends Event {\n  /**\n   * @param {SelectEventType} type The event type.\n   * @param {Array<import(\"../Feature.js\").default>} selected Selected features.\n   * @param {Array<import(\"../Feature.js\").default>} deselected Deselected features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Associated\n   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, selected, deselected, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * Selected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.selected = selected;\n\n    /**\n     * Deselected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.deselected = deselected;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/**\n * Original feature styles to reset to when features are no longer selected.\n * @type {Object<number, import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction>}\n */\nconst originalFeatureStyles = {};\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'select', SelectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'select', Return>} SelectOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for selecting vector features. By default, selected features are\n * styled differently, so this interaction can be used for visual highlighting,\n * as well as selecting features for other actions, such as modification or\n * output. There are three ways of controlling which features are selected:\n * using the browser event as defined by the `condition` and optionally the\n * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\n * further feature filter using the `filter` option.\n *\n * @fires SelectEvent\n * @api\n */\nclass Select extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SelectOnSignature<void>}\n     */\n    this.un;\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     */\n    this.boundAddFeature_ = this.addFeature_.bind(this);\n\n    /**\n     * @private\n     */\n    this.boundRemoveFeature_ = this.removeFeature_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : singleClick;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.addCondition_ = options.addCondition ? options.addCondition : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.removeCondition_ = options.removeCondition\n      ? options.removeCondition\n      : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.toggleCondition_ = options.toggleCondition\n      ? options.toggleCondition\n      : shiftKeyOnly;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multi_ = options.multi ? options.multi : false;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction|null}\n     */\n    this.style_ =\n      options.style !== undefined ? options.style : getDefaultStyleFunction();\n\n    /**\n     * @private\n     * @type {Collection<Feature>}\n     */\n    this.features_ = options.features || new Collection();\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * An association between selected feature (key)\n     * and layer (value)\n     * @private\n     * @type {Object<string, import(\"../layer/Layer.js\").default>}\n     */\n    this.featureLayerAssociation_ = {};\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"../layer/Layer.js\").default} layer Layer.\n   * @private\n   */\n  addFeatureLayerAssociation_(feature, layer) {\n    this.featureLayerAssociation_[getUid(feature)] = layer;\n  }\n\n  /**\n   * Get the selected features.\n   * @return {Collection<Feature>} Features collection.\n   * @api\n   */\n  getFeatures() {\n    return this.features_;\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of\n   * a selected feature.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @return {import('../layer/Vector.js').default} Layer.\n   * @api\n   */\n  getLayer(feature) {\n    return /** @type {import('../layer/Vector.js').default} */ (\n      this.featureLayerAssociation_[getUid(feature)]\n    );\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   * @override\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    if (currentMap && this.style_) {\n      this.features_.forEach(this.restorePreviousStyle_.bind(this));\n    }\n    super.setMap(map);\n    if (map) {\n      this.features_.addEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_,\n      );\n      this.features_.addEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_,\n      );\n\n      if (this.style_) {\n        this.features_.forEach(this.applySelectedStyle_.bind(this));\n      }\n    } else {\n      this.features_.removeEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_,\n      );\n      this.features_.removeEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_,\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  addFeature_(evt) {\n    const feature = evt.element;\n    if (this.style_) {\n      this.applySelectedStyle_(feature);\n    }\n    if (!this.getLayer(feature)) {\n      const layer = /** @type {VectorLayer} */ (\n        this.getMap()\n          .getAllLayers()\n          .find(function (layer) {\n            if (\n              layer instanceof VectorLayer &&\n              layer.getSource() &&\n              layer.getSource().hasFeature(feature)\n            ) {\n              return layer;\n            }\n          })\n      );\n      if (layer) {\n        this.addFeatureLayerAssociation_(feature, layer);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  removeFeature_(evt) {\n    if (this.style_) {\n      this.restorePreviousStyle_(evt.element);\n    }\n  }\n\n  /**\n   * @return {import(\"../style/Style.js\").StyleLike|null} Select style.\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  applySelectedStyle_(feature) {\n    const key = getUid(feature);\n    if (!(key in originalFeatureStyles)) {\n      originalFeatureStyles[key] = feature.getStyle();\n    }\n    feature.setStyle(this.style_);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  restorePreviousStyle_(feature) {\n    const interactions = this.getMap().getInteractions().getArray();\n    for (let i = interactions.length - 1; i >= 0; --i) {\n      const interaction = interactions[i];\n      if (\n        interaction !== this &&\n        interaction instanceof Select &&\n        interaction.getStyle() &&\n        interaction.getFeatures().getArray().lastIndexOf(feature) !== -1\n      ) {\n        feature.setStyle(interaction.getStyle());\n        return;\n      }\n    }\n\n    const key = getUid(feature);\n    feature.setStyle(originalFeatureStyles[key]);\n    delete originalFeatureStyles[key];\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureLayerAssociation_(feature) {\n    delete this.featureLayerAssociation_[getUid(feature)];\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the\n   * selected state of features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @override\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const add = this.addCondition_(mapBrowserEvent);\n    const remove = this.removeCondition_(mapBrowserEvent);\n    const toggle = this.toggleCondition_(mapBrowserEvent);\n    const set = !add && !remove && !toggle;\n    const map = mapBrowserEvent.map;\n    const features = this.getFeatures();\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const deselected = [];\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const selected = [];\n\n    if (set) {\n      // Replace the currently selected feature(s) with the feature(s) at the\n      // pixel, or clear the selected feature(s) if there is no feature at\n      // the pixel.\n      clear(this.featureLayerAssociation_);\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        (feature, layer) => {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          this.addFeatureLayerAssociation_(feature, layer);\n          selected.push(feature);\n          return !this.multi_;\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        },\n      );\n      for (let i = features.getLength() - 1; i >= 0; --i) {\n        const feature = features.item(i);\n        const index = selected.indexOf(feature);\n        if (index > -1) {\n          // feature is already selected\n          selected.splice(index, 1);\n        } else {\n          features.remove(feature);\n          deselected.push(feature);\n        }\n      }\n      if (selected.length !== 0) {\n        features.extend(selected);\n      }\n    } else {\n      // Modify the currently selected feature(s).\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        (feature, layer) => {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          if ((add || toggle) && !features.getArray().includes(feature)) {\n            this.addFeatureLayerAssociation_(feature, layer);\n            selected.push(feature);\n          } else if (\n            (remove || toggle) &&\n            features.getArray().includes(feature)\n          ) {\n            deselected.push(feature);\n            this.removeFeatureLayerAssociation_(feature);\n          }\n          return !this.multi_;\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        },\n      );\n      for (let j = deselected.length - 1; j >= 0; --j) {\n        features.remove(deselected[j]);\n      }\n      features.extend(selected);\n    }\n    if (selected.length > 0 || deselected.length > 0) {\n      this.dispatchEvent(\n        new SelectEvent(\n          SelectEventType.SELECT,\n          selected,\n          deselected,\n          mapBrowserEvent,\n        ),\n      );\n    }\n    return true;\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  extend(styles['Polygon'], styles['LineString']);\n  extend(styles['GeometryCollection'], styles['LineString']);\n\n  return function (feature) {\n    if (!feature.getGeometry()) {\n      return null;\n    }\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\nexport default Select;\n","/**\n * @module ol/geom/Circle\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {rotate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends SimpleGeometry {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const circle = new Circle(\n      this.flatCoordinates.slice(),\n      undefined,\n      this.layout,\n    );\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   * @override\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @override\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius,\n      flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius,\n      flatCoordinates[1] + radius,\n      extent,\n    );\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      const center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  /**\n   * @override\n   */\n  getCoordinates() {\n    return null;\n  }\n\n  /**\n   * @override\n   */\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   * @override\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      rotate(center, 0, center.length, stride, angle, anchor, center),\n    );\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n","/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {\n  always,\n  never,\n  noModifierKeys,\n  shiftKeyOnly,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../extent.js';\nimport {clamp, squaredDistance, toFixed} from '../math.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {\n  distance,\n  squaredDistance as squaredCoordinateDistance,\n} from '../coordinate.js';\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.\n * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.\n * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with\n * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.\n * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`\n * geometry that corresponds to the polygon between the already drawn points and the current cursor position\n * (note that this polygon has only two points if only one point is drawn).\n * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose\n * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\n * Ignored when in freehand mode.\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\n * either a `traceSource` or a `source`.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * @typedef {Object} TraceState\n * @property {boolean} active Tracing active.\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\n * that no trace target is active.\n */\n\n/**\n * @typedef {Object} TraceTarget\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\n * @property {boolean} ring The target coordinates are a linear ring.\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n */\n\n/**\n * @enum {string}\n */\nconst DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nexport class DrawEvent extends Event {\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n  constructor(type, feature) {\n    super(type);\n\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    this.feature = feature;\n  }\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {Array<Feature>} features The candidate features.\n * @return {Array<TraceTarget>} The trace targets.\n */\nfunction getTraceTargets(coordinate, features) {\n  /**\n   * @type {Array<TraceTarget>}\n   */\n  const targets = [];\n\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    const geometry = feature.getGeometry();\n    appendGeometryTraceTargets(coordinate, geometry, targets);\n  }\n\n  return targets;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\n * @return {number} The squared distance between the two coordinates.\n */\nfunction getSquaredDistance(a, b) {\n  return squaredDistance(a[0], a[1], b[0], b[1]);\n}\n\n/**\n * @param {LineCoordType} coordinates The ring coordinates.\n * @param {number} index The index.  May be wrapped.\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\n */\nfunction getCoordinate(coordinates, index) {\n  const count = coordinates.length;\n  if (index < 0) {\n    return coordinates[index + count];\n  }\n  if (index >= count) {\n    return coordinates[index - count];\n  }\n  return coordinates[index];\n}\n\n/**\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\n * be less than the start index to indicate the direction of travel.  The start and end index may have\n * a fractional part to indicate a point between two coordinates.\n * @param {LineCoordType} coordinates Ring coordinates.\n * @param {number} startIndex The start index.\n * @param {number} endIndex The end index.\n * @return {number} The cumulative squared distance along the ring path.\n */\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\n  let lowIndex, highIndex;\n  if (startIndex < endIndex) {\n    lowIndex = startIndex;\n    highIndex = endIndex;\n  } else {\n    lowIndex = endIndex;\n    highIndex = startIndex;\n  }\n  const lowWholeIndex = Math.ceil(lowIndex);\n  const highWholeIndex = Math.floor(highIndex);\n\n  if (lowWholeIndex > highWholeIndex) {\n    // both start and end are on the same segment\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    return getSquaredDistance(start, end);\n  }\n\n  let sd = 0;\n\n  if (lowIndex < lowWholeIndex) {\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = getCoordinate(coordinates, lowWholeIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  if (highWholeIndex < highIndex) {\n    const start = getCoordinate(coordinates, highWholeIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\n    const start = getCoordinate(coordinates, i);\n    const end = getCoordinate(coordinates, i + 1);\n    sd += getSquaredDistance(start, end);\n  }\n\n  return sd;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\n  if (geometry instanceof LineString) {\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\n    return;\n  }\n  if (geometry instanceof MultiLineString) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\n    }\n    return;\n  }\n  if (geometry instanceof Polygon) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], true, targets);\n    }\n    return;\n  }\n  if (geometry instanceof MultiPolygon) {\n    const polys = geometry.getCoordinates();\n    for (let i = 0, ii = polys.length; i < ii; ++i) {\n      const coordinates = polys[i];\n      for (let j = 0, jj = coordinates.length; j < jj; ++j) {\n        appendTraceTarget(coordinate, coordinates[j], true, targets);\n      }\n    }\n    return;\n  }\n  if (geometry instanceof GeometryCollection) {\n    const geometries = geometry.getGeometries();\n    for (let i = 0; i < geometries.length; ++i) {\n      appendGeometryTraceTargets(coordinate, geometries[i], targets);\n    }\n    return;\n  }\n  // other types cannot be traced\n}\n\n/**\n * @typedef {Object} TraceTargetUpdateInfo\n * @property {number} index The new target index.\n * @property {number} endIndex The new segment end index.\n */\n\n/**\n * @type {TraceTargetUpdateInfo}\n */\nconst sharedUpdateInfo = {index: -1, endIndex: NaN};\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {TraceState} traceState The trace state.\n * @param {import(\"../Map.js\").default} map The map.\n * @param {number} snapTolerance The snap tolerance.\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\n * object is reused between calls and must not be modified by the caller.\n */\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n\n  let closestTargetDistance = Infinity;\n\n  let newTargetIndex = -1;\n  let newEndIndex = NaN;\n\n  for (\n    let targetIndex = 0;\n    targetIndex < traceState.targets.length;\n    ++targetIndex\n  ) {\n    const target = traceState.targets[targetIndex];\n    const coordinates = target.coordinates;\n\n    let minSegmentDistance = Infinity;\n    let endIndex;\n    for (\n      let coordinateIndex = 0;\n      coordinateIndex < coordinates.length - 1;\n      ++coordinateIndex\n    ) {\n      const start = coordinates[coordinateIndex];\n      const end = coordinates[coordinateIndex + 1];\n      const rel = getPointSegmentRelationship(x, y, start, end);\n      if (rel.squaredDistance < minSegmentDistance) {\n        minSegmentDistance = rel.squaredDistance;\n        endIndex = coordinateIndex + rel.along;\n      }\n    }\n\n    if (minSegmentDistance < closestTargetDistance) {\n      closestTargetDistance = minSegmentDistance;\n      if (target.ring && traceState.targetIndex === targetIndex) {\n        // same target, maintain the same trace direction\n        if (target.endIndex > target.startIndex) {\n          // forward trace\n          if (endIndex < target.startIndex) {\n            endIndex += coordinates.length;\n          }\n        } else if (target.endIndex < target.startIndex) {\n          // reverse trace\n          if (endIndex > target.startIndex) {\n            endIndex -= coordinates.length;\n          }\n        }\n      }\n      newEndIndex = endIndex;\n      newTargetIndex = targetIndex;\n    }\n  }\n\n  const newTarget = traceState.targets[newTargetIndex];\n  let considerBothDirections = newTarget.ring;\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\n    // only consider switching trace direction if close to the start\n    const newCoordinate = interpolateCoordinate(\n      newTarget.coordinates,\n      newEndIndex,\n    );\n    const pixel = map.getPixelFromCoordinate(newCoordinate);\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\n      considerBothDirections = false;\n    }\n  }\n\n  if (considerBothDirections) {\n    const coordinates = newTarget.coordinates;\n    const count = coordinates.length;\n    const startIndex = newTarget.startIndex;\n    const endIndex = newEndIndex;\n    if (startIndex < endIndex) {\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex,\n      );\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex - count,\n      );\n      if (reverseDistance < forwardDistance) {\n        newEndIndex -= count;\n      }\n    } else {\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex,\n      );\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex + count,\n      );\n      if (forwardDistance < reverseDistance) {\n        newEndIndex += count;\n      }\n    }\n  }\n\n  sharedUpdateInfo.index = newTargetIndex;\n  sharedUpdateInfo.endIndex = newEndIndex;\n  return sharedUpdateInfo;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\n * @param {boolean} ring The coordinates represent a linear ring.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    const start = coordinates[i];\n    const end = coordinates[i + 1];\n    const rel = getPointSegmentRelationship(x, y, start, end);\n    if (rel.squaredDistance === 0) {\n      const index = i + rel.along;\n      targets.push({\n        coordinates: coordinates,\n        ring: ring,\n        startIndex: index,\n        endIndex: index,\n      });\n      return;\n    }\n  }\n}\n\n/**\n * @typedef {Object} PointSegmentRelationship\n * @property {number} along The closest point expressed as a fraction along the segment length.\n * @property {number} squaredDistance The squared distance of the point to the segment.\n */\n\n/**\n * @type {PointSegmentRelationship}\n */\nconst sharedRel = {along: 0, squaredDistance: 0};\n\n/**\n * @param {number} x The point x.\n * @param {number} y The point y.\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\n * shared between calls and must not be modified by the caller.\n */\nfunction getPointSegmentRelationship(x, y, start, end) {\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  let along = 0;\n  let px = x1;\n  let py = y1;\n  if (dx !== 0 || dy !== 0) {\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\n    px += dx * along;\n    py += dy * along;\n  }\n\n  sharedRel.along = along;\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\n  return sharedRel;\n}\n\n/**\n * @param {LineCoordType} coordinates The coordinates.\n * @param {number} index The index.  May be fractional and may wrap.\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\n */\nfunction interpolateCoordinate(coordinates, index) {\n  const count = coordinates.length;\n\n  let startIndex = Math.floor(index);\n  const along = index - startIndex;\n  if (startIndex >= count) {\n    startIndex -= count;\n  } else if (startIndex < 0) {\n    startIndex += count;\n  }\n\n  let endIndex = startIndex + 1;\n  if (endIndex >= count) {\n    endIndex -= count;\n  }\n\n  const start = coordinates[startIndex];\n  const x0 = start[0];\n  const y0 = start[1];\n  const end = coordinates[endIndex];\n  const dx = end[0] - x0;\n  const dy = end[1] - y0;\n\n  return [x0 + dx * along, y0 + dy * along];\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nclass Draw extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.shouldHandle_ = false;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.downPx_ = null;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    this.downTimeout_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.lastDragTime_;\n\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n    this.pointerType_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.freehand_ = false;\n\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/Geometry.js\").Type}\n     * @private\n     */\n    this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (\n      options.type\n    );\n\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    this.mode_ = getMode(this.type_);\n\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    this.stopClick_ = !!options.stopClick;\n\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    this.minPoints_ = options.minPoints\n      ? options.minPoints\n      : this.mode_ === 'Polygon'\n        ? 3\n        : 2;\n\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    this.maxPoints_ =\n      this.mode_ === 'Circle'\n        ? 2\n        : options.maxPoints\n          ? options.maxPoints\n          : Infinity;\n\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.finishCondition_ = options.finishCondition\n      ? options.finishCondition\n      : TRUE;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout\n      ? options.geometryLayout\n      : 'XY';\n\n    let geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      const mode = this.mode_;\n      if (mode === 'Circle') {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = (coordinates, geometry, projection) => {\n          const circle = geometry\n            ? /** @type {Circle} */ (geometry)\n            : new Circle([NaN, NaN]);\n          const center = fromUserCoordinate(coordinates[0], projection);\n          const squaredLength = squaredCoordinateDistance(\n            center,\n            fromUserCoordinate(coordinates[coordinates.length - 1], projection),\n          );\n          circle.setCenterAndRadius(\n            center,\n            Math.sqrt(squaredLength),\n            this.geometryLayout_,\n          );\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n          return circle;\n        };\n      } else {\n        let Constructor;\n        if (mode === 'Point') {\n          Constructor = Point;\n        } else if (mode === 'LineString') {\n          Constructor = LineString;\n        } else if (mode === 'Polygon') {\n          Constructor = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = (coordinates, geometry, projection) => {\n          if (geometry) {\n            if (mode === 'Polygon') {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates(\n                  [coordinates[0].concat([coordinates[0][0]])],\n                  this.geometryLayout_,\n                );\n              } else {\n                geometry.setCoordinates([], this.geometryLayout_);\n              }\n            } else {\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\n            }\n          } else {\n            geometry = new Constructor(coordinates, this.geometryLayout_);\n          }\n          return geometry;\n        };\n      }\n    }\n\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    this.geometryFunction_ = geometryFunction;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dragVertexDelay_ =\n      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.finishCoordinate_ = null;\n\n    /**\n     * Sketch feature.\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n     * @private\n     */\n    this.sketchFeature_ = null;\n\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.sketchPoint_ = null;\n\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    this.sketchCoords_ = null;\n\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n    this.sketchLine_ = null;\n\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    this.sketchLineCoords_ = null;\n\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    this.squaredClickTolerance_ = options.clickTolerance\n      ? options.clickTolerance * options.clickTolerance\n      : 36;\n\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.freehandCondition_;\n    if (options.freehand) {\n      this.freehandCondition_ = always;\n    } else {\n      this.freehandCondition_ = options.freehandCondition\n        ? options.freehandCondition\n        : shiftKeyOnly;\n    }\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.traceCondition_;\n    this.setTrace(options.trace || false);\n\n    /**\n     * @type {TraceState}\n     * @private\n     */\n    this.traceState_ = {active: false};\n\n    /**\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.traceSource_ = options.traceSource || options.source || null;\n\n    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);\n  }\n\n  /**\n   * Toggle tracing mode or set a tracing condition.\n   *\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\n   */\n  setTrace(trace) {\n    let condition;\n    if (!trace) {\n      condition = never;\n    } else if (trace === true) {\n      condition = always;\n    } else {\n      condition = trace;\n    }\n    this.traceCondition_ = condition;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   * @override\n   */\n  setMap(map) {\n    super.setMap(map);\n    this.updateState_();\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   * @override\n   */\n  handleEvent(event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.originalEvent.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\n    let move = event.type === MapBrowserEventType.POINTERMOVE;\n    let pass = true;\n    if (\n      !this.freehand_ &&\n      this.lastDragTime_ &&\n      event.type === MapBrowserEventType.POINTERDRAG\n    ) {\n      const now = Date.now();\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n    if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDRAG &&\n      this.sketchFeature_ !== null\n    ) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDOWN\n    ) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n        if (this.shouldHandle_) {\n          // Avoid page scrolling when freehand drawing on mobile\n          event.originalEvent.preventDefault();\n        }\n      } else if (\n        event.originalEvent.pointerType === 'mouse' ||\n        (event.type === MapBrowserEventType.POINTERDRAG &&\n          this.downTimeout_ === undefined)\n      ) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return super.handleEvent(event) && pass;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleDownEvent(event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n      return true;\n    }\n\n    if (!this.condition_(event)) {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n\n    this.lastDragTime_ = Date.now();\n    this.downTimeout_ = setTimeout(() => {\n      this.handlePointerMove_(\n        new MapBrowserEvent(\n          MapBrowserEventType.POINTERMOVE,\n          event.map,\n          event.originalEvent,\n          false,\n          event.frameState,\n        ),\n      );\n    }, this.dragVertexDelay_);\n    this.downPx_ = event.pixel;\n    return true;\n  }\n\n  /**\n   * @private\n   */\n  deactivateTrace_() {\n    this.traceState_ = {active: false};\n  }\n\n  /**\n   * Activate or deactivate trace state based on a browser event.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  toggleTraceState_(event) {\n    if (!this.traceSource_ || !this.traceCondition_(event)) {\n      return;\n    }\n\n    if (this.traceState_.active) {\n      this.deactivateTrace_();\n      return;\n    }\n\n    const map = this.getMap();\n    const lowerLeft = map.getCoordinateFromPixel([\n      event.pixel[0] - this.snapTolerance_,\n      event.pixel[1] + this.snapTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      event.pixel[0] + this.snapTolerance_,\n      event.pixel[1] - this.snapTolerance_,\n    ]);\n    const extent = boundingExtent([lowerLeft, upperRight]);\n    const features = this.traceSource_.getFeaturesInExtent(extent);\n    if (features.length === 0) {\n      return;\n    }\n\n    const targets = getTraceTargets(event.coordinate, features);\n    if (targets.length) {\n      this.traceState_ = {\n        active: true,\n        startPx: event.pixel.slice(),\n        targets: targets,\n        targetIndex: -1,\n      };\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} endIndex The new end index of the trace.\n   * @private\n   */\n  addOrRemoveTracedCoordinates_(target, endIndex) {\n    // three cases to handle:\n    //  1. traced in the same direction and points need adding\n    //  2. traced in the same direction and points need removing\n    //  3. traced in a new direction\n    const previouslyForward = target.startIndex <= target.endIndex;\n    const currentlyForward = target.startIndex <= endIndex;\n    if (previouslyForward === currentlyForward) {\n      // same direction\n      if (\n        (previouslyForward && endIndex > target.endIndex) ||\n        (!previouslyForward && endIndex < target.endIndex)\n      ) {\n        // case 1 - add new points\n        this.addTracedCoordinates_(target, target.endIndex, endIndex);\n      } else if (\n        (previouslyForward && endIndex < target.endIndex) ||\n        (!previouslyForward && endIndex > target.endIndex)\n      ) {\n        // case 2 - remove old points\n        this.removeTracedCoordinates_(endIndex, target.endIndex);\n      }\n    } else {\n      // case 3 - remove old points, add new points\n      this.removeTracedCoordinates_(target.startIndex, target.endIndex);\n      this.addTracedCoordinates_(target, target.startIndex, endIndex);\n    }\n  }\n\n  /**\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  removeTracedCoordinates_(fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    let remove = 0;\n    if (fromIndex < toIndex) {\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        end -= 1;\n      }\n      remove = end - start + 1;\n    } else {\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      remove = start - end + 1;\n    }\n\n    if (remove > 0) {\n      this.removeLastPoints_(remove);\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  addTracedCoordinates_(target, fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    const coordinates = [];\n    if (fromIndex < toIndex) {\n      // forward trace\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        // if end is snapped to a vertex, it will be added later\n        end -= 1;\n      }\n      for (let i = start; i <= end; ++i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    } else {\n      // reverse trace\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      for (let i = start; i >= end; --i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    }\n    if (coordinates.length) {\n      this.appendCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * Update the trace.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  updateTrace_(event) {\n    const traceState = this.traceState_;\n    if (!traceState.active) {\n      return;\n    }\n\n    if (traceState.targetIndex === -1) {\n      // check if we are ready to pick a target\n      if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\n        return;\n      }\n    }\n\n    const updatedTraceTarget = getTraceTargetUpdate(\n      event.coordinate,\n      traceState,\n      this.getMap(),\n      this.snapTolerance_,\n    );\n\n    if (traceState.targetIndex !== updatedTraceTarget.index) {\n      // target changed\n      if (traceState.targetIndex !== -1) {\n        // remove points added during previous trace\n        const oldTarget = traceState.targets[traceState.targetIndex];\n        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\n      }\n      // add points for the new target\n      const newTarget = traceState.targets[updatedTraceTarget.index];\n      this.addTracedCoordinates_(\n        newTarget,\n        newTarget.startIndex,\n        updatedTraceTarget.endIndex,\n      );\n    } else {\n      // target stayed the same\n      const target = traceState.targets[traceState.targetIndex];\n      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);\n    }\n\n    // modify the state with updated info\n    traceState.targetIndex = updatedTraceTarget.index;\n    const target = traceState.targets[traceState.targetIndex];\n    target.endIndex = updatedTraceTarget.endIndex;\n\n    // update event coordinate and pixel to match end point of final segment\n    const coordinate = interpolateCoordinate(\n      target.coordinates,\n      target.endIndex,\n    );\n    const pixel = this.getMap().getPixelFromCoordinate(coordinate);\n    event.coordinate = coordinate;\n    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(event) {\n    let pass = true;\n\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n\n      this.handlePointerMove_(event);\n      const tracing = this.traceState_.active;\n      this.toggleTraceState_(event);\n\n      if (this.shouldHandle_) {\n        const startingToDraw = !this.finishCoordinate_;\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (\n          !this.freehand_ &&\n          (!startingToDraw || this.mode_ === 'Point')\n        ) {\n          if (this.atFinish_(event.pixel, tracing)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n    return pass;\n  }\n\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @private\n   */\n  handlePointerMove_(event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n    if (\n      this.downPx_ &&\n      ((!this.freehand_ && this.shouldHandle_) ||\n        (this.freehand_ && !this.shouldHandle_))\n    ) {\n      const downPx = this.downPx_;\n      const clickPx = event.pixel;\n      const dx = downPx[0] - clickPx[0];\n      const dy = downPx[1] - clickPx[1];\n      const squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_\n        ? squaredDistance > this.squaredClickTolerance_\n        : squaredDistance <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n\n    if (!this.finishCoordinate_) {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n      return;\n    }\n\n    this.updateTrace_(event);\n    this.modifyDrawing_(event.coordinate);\n  }\n\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  atFinish_(pixel, tracing) {\n    let at = false;\n    if (this.sketchFeature_) {\n      let potentiallyDone = false;\n      let potentiallyFinishCoordinates = [this.finishCoordinate_];\n      const mode = this.mode_;\n      if (mode === 'Point') {\n        at = true;\n      } else if (mode === 'Circle') {\n        at = this.sketchCoords_.length === 2;\n      } else if (mode === 'LineString') {\n        potentiallyDone =\n          !tracing && this.sketchCoords_.length > this.minPoints_;\n      } else if (mode === 'Polygon') {\n        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [\n          sketchCoords[0][0],\n          sketchCoords[0][sketchCoords[0].length - 2],\n        ];\n        if (tracing) {\n          potentiallyFinishCoordinates = [sketchCoords[0][0]];\n        } else {\n          potentiallyFinishCoordinates = [\n            sketchCoords[0][0],\n            sketchCoords[0][sketchCoords[0].length - 2],\n          ];\n        }\n      }\n      if (potentiallyDone) {\n        const map = this.getMap();\n        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          const finishCoordinate = potentiallyFinishCoordinates[i];\n          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          const dx = pixel[0] - finishPixel[0];\n          const dy = pixel[1] - finishPixel[1];\n          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  }\n\n  /**\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n   * @private\n   */\n  createOrUpdateSketchPoint_(coordinates) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @private\n   */\n  createOrUpdateCustomSketchLine_(geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature();\n    }\n    const ring = geometry.getLinearRing(0);\n    let sketchLineGeom = this.sketchLine_.getGeometry();\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString(\n        ring.getFlatCoordinates(),\n        ring.getLayout(),\n      );\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(\n        ring.getLayout(),\n        ring.getFlatCoordinates(),\n      );\n      sketchLineGeom.changed();\n    }\n  }\n\n  /**\n   * Start the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n   * @private\n   */\n  startDrawing_(start) {\n    const projection = this.getMap().getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    while (start.length < stride) {\n      start.push(0);\n    }\n    this.finishCoordinate_ = start;\n    if (this.mode_ === 'Point') {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === 'Polygon') {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n    }\n    const geometry = this.geometryFunction_(\n      this.sketchCoords_,\n      undefined,\n      projection,\n    );\n    this.sketchFeature_ = new Feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_),\n    );\n  }\n\n  /**\n   * Modify the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @private\n   */\n  modifyDrawing_(coordinate) {\n    const map = this.getMap();\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = map.getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    let coordinates, last;\n    while (coordinate.length < stride) {\n      coordinate.push(0);\n    }\n    if (this.mode_ === 'Point') {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(\n      /** @type {!LineCoordType} */ (this.sketchCoords_),\n      geometry,\n      projection,\n    );\n    if (this.sketchPoint_) {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\n      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n    } else if (this.sketchLineCoords_) {\n      const sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {!PointCoordType} coordinate Coordinate\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>} The sketch feature.\n   * @private\n   */\n  addToDrawing_(coordinate) {\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    let done;\n    let coordinates;\n    const mode = this.mode_;\n    if (mode === 'LineString' || mode === 'Circle') {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (mode === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n    if (done) {\n      return this.finishDrawing();\n    }\n    return this.sketchFeature_;\n  }\n\n  /**\n   * @param {number} n The number of points to remove.\n   */\n  removeLastPoints_(n) {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    const mode = this.mode_;\n    for (let i = 0; i < n; ++i) {\n      let coordinates;\n      if (mode === 'LineString' || mode === 'Circle') {\n        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n        coordinates.splice(-2, 1);\n        if (coordinates.length >= 2) {\n          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n          const finishCoordinate = this.finishCoordinate_.slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        this.geometryFunction_(coordinates, geometry, projection);\n        if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n          this.createOrUpdateCustomSketchLine_(\n            /** @type {Polygon} */ (geometry),\n          );\n        }\n      } else if (mode === 'Polygon') {\n        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n        coordinates.splice(-2, 1);\n        const sketchLineGeom = this.sketchLine_.getGeometry();\n        if (coordinates.length >= 2) {\n          const finishCoordinate = coordinates[coordinates.length - 2].slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        sketchLineGeom.setCoordinates(coordinates);\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\n      }\n\n      if (coordinates.length === 1) {\n        this.abortDrawing();\n        break;\n      }\n    }\n\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Remove last point of the feature currently being drawn. Does not do anything when\n   * drawing POINT or MULTI_POINT geometries.\n   * @api\n   */\n  removeLastPoint() {\n    this.removeLastPoints_(1);\n  }\n\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The drawn feature.\n   * @api\n   */\n  finishDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return null;\n    }\n    let coordinates = this.sketchCoords_;\n    const geometry = sketchFeature.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    if (this.mode_ === 'LineString') {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (this.mode_ === 'Polygon') {\n      // remove the redundant last point in ring\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n      coordinates = geometry.getCoordinates();\n    }\n\n    // cast multi-part geometries\n    if (this.type_ === 'MultiPoint') {\n      sketchFeature.setGeometry(\n        new MultiPoint([/** @type {PointCoordType} */ (coordinates)]),\n      );\n    } else if (this.type_ === 'MultiLineString') {\n      sketchFeature.setGeometry(\n        new MultiLineString([/** @type {LineCoordType} */ (coordinates)]),\n      );\n    } else if (this.type_ === 'MultiPolygon') {\n      sketchFeature.setGeometry(\n        new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)]),\n      );\n    }\n\n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n\n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n   * @private\n   */\n  abortDrawing_() {\n    this.finishCoordinate_ = null;\n    const sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    this.deactivateTrace_();\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @api\n   */\n  abortDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  }\n\n  /**\n   * Append coordinates to the end of the geometry that is currently being drawn.\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\n   * either be appended to the current LineString or the outer ring of the current\n   * Polygon. If no geometry is being drawn, a new one will be created.\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n   * the coordinate array.\n   * @api\n   */\n  appendCoordinates(coordinates) {\n    const mode = this.mode_;\n    const newDrawing = !this.sketchFeature_;\n    if (newDrawing) {\n      this.startDrawing_(coordinates[0]);\n    }\n    /** @type {LineCoordType} */\n    let sketchCoords;\n    if (mode === 'LineString' || mode === 'Circle') {\n      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n    } else if (mode === 'Polygon') {\n      sketchCoords =\n        this.sketchCoords_ && this.sketchCoords_.length\n          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n          : [];\n    } else {\n      return;\n    }\n\n    if (newDrawing) {\n      sketchCoords.shift();\n    }\n\n    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n    sketchCoords.pop();\n\n    // Append coordinate list\n    for (let i = 0; i < coordinates.length; i++) {\n      this.addToDrawing_(coordinates[i]);\n    }\n\n    const ending = coordinates[coordinates.length - 1];\n    // Duplicate last coordinate for sketch drawing (cursor position)\n    this.sketchFeature_ = this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  }\n\n  /**\n   * Initiate draw mode by starting from an existing geometry which will\n   * receive new additional points. This only works on features with\n   * `LineString` geometries, where the interaction will extend lines by adding\n   * points to the end of the coordinates array.\n   * This will change the original feature, instead of drawing a copy.\n   *\n   * The function will dispatch a `drawstart` event.\n   *\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n  extend(feature) {\n    const geometry = feature.getGeometry();\n    const lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    const last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new Feature(new Point(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_),\n    );\n  }\n\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  updateSketchFeatures_() {\n    const sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    const overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  }\n\n  /**\n   * @private\n   */\n  updateState_() {\n    const map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n    this.overlay_.setMap(active ? map : null);\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(sides, angle) {\n  return function (coordinates, geometry, projection) {\n    const center = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[0],\n      projection,\n    );\n    const end = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],\n      projection,\n    );\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    geometry = geometry || fromCircle(new Circle(center), sides);\n\n    let internalAngle = angle;\n    if (!angle && angle !== 0) {\n      const x = end[0] - center[0];\n      const y = end[1] - center[1];\n      internalAngle = Math.atan2(y, x);\n    }\n    makeRegular(\n      /** @type {Polygon} */ (geometry),\n      center,\n      radius,\n      internalAngle,\n    );\n\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n  return function (coordinates, geometry, projection) {\n    const extent = boundingExtent(\n      /** @type {LineCoordType} */ ([\n        coordinates[0],\n        coordinates[coordinates.length - 1],\n      ]).map(function (coordinate) {\n        return fromUserCoordinate(coordinate, projection);\n      }),\n    );\n    const boxCoordinates = [\n      [\n        getBottomLeft(extent),\n        getBottomRight(extent),\n        getTopRight(extent),\n        getTopLeft(extent),\n        getBottomLeft(extent),\n      ],\n    ];\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      return 'Point';\n    case 'LineString':\n    case 'MultiLineString':\n      return 'LineString';\n    case 'Polygon':\n    case 'MultiPolygon':\n      return 'Polygon';\n    case 'Circle':\n      return 'Circle';\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\n\nexport default Draw;\n","/**\n * @module ol/interaction/Modify\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {\n  altKeyOnly,\n  always,\n  primaryAction,\n  singleClick,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  buffer as bufferExtent,\n  createOrUpdateFromCoordinate as createExtent,\n} from '../extent.js';\nimport {\n  closestOnSegment,\n  distance as coordinateDistance,\n  equals as coordinatesEqual,\n  squaredDistance as squaredCoordinateDistance,\n  squaredDistanceToSegment,\n} from '../coordinate.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {equals} from '../array.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  fromUserExtent,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {getUid} from '../util.js';\n\n/**\n * The segment index assigned to a circle's center when\n * breaking up a circle into ModifySegmentDataType segments.\n * @type {number}\n */\nconst CIRCLE_CENTER_INDEX = 0;\n\n/**\n * The segment index assigned to a circle's circumference when\n * breaking up a circle into ModifySegmentDataType segments.\n * @type {number}\n */\nconst CIRCLE_CIRCUMFERENCE_INDEX = 1;\n\nconst tempExtent = [0, 0, 0, 0];\nconst tempSegment = [];\n\n/**\n * @enum {string}\n */\nconst ModifyEventType = {\n  /**\n   * Triggered upon feature modification start\n   * @event ModifyEvent#modifystart\n   * @api\n   */\n  MODIFYSTART: 'modifystart',\n  /**\n   * Triggered upon feature modification end\n   * @event ModifyEvent#modifyend\n   * @api\n   */\n  MODIFYEND: 'modifyend',\n};\n\n/**\n * @typedef {Object} SegmentData\n * @property {Array<number>} [depth] Depth.\n * @property {Feature} feature Feature.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} [index] Index.\n * @property {Array<Array<number>>} segment Segment.\n * @property {Array<SegmentData>} [featureSegments] FeatureSegments.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event will be considered to add or move a\n * vertex to the sketch. Default is\n * {@link module:ol/events/condition.primaryAction}.\n * @property {import(\"../events/condition.js\").Condition} [deleteCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. By default,\n * {@link module:ol/events/condition.singleClick} with\n * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.\n * @property {import(\"../events/condition.js\").Condition} [insertVertexCondition] A\n * function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether a new vertex should be added to the sketch\n * features. Default is {@link module:ol/events/condition.always}.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\n * pointer close enough to a segment or vertex for editing.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style used for the modification point or vertex. For linestrings and polygons, this will\n * be the affected vertex, for circles a point along the circle, and for points the actual\n * point. If not configured, the default edit style is used (see {@link module:ol/style/Style~Style}).\n * When using a style function, the point feature passed to the function will have a `features`\n * property - an array whose entries are the features that are being modified, and a `geometries`\n * property - an array whose entries are the geometries that are being modified. Both arrays are\n * in the same order. The `geometries` are only useful when modifying geometry collections, where\n * the geometry will be the particular geometry from the collection that is being modified.\n * @property {VectorSource} [source] The vector source with\n * features to modify.  If a vector source is not provided, a feature collection\n * must be provided with the `features` option.\n * @property {boolean|import(\"../layer/BaseVector\").default} [hitDetection] When configured, point\n * features will be considered for modification based on their visual appearance, instead of being within\n * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector~BaseVectorLayer} is\n * provided, only the rendered representation of the features on that layer will be considered.\n * @property {Collection<Feature>} [features]\n * The features the interaction works on.  If a feature collection is not\n * provided, a vector source must be provided with the `source` option.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the\n * pointer coordinate when clicked within the `pixelTolerance`.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are\n * instances of this type.\n */\nexport class ModifyEvent extends Event {\n  /**\n   * @param {ModifyEventType} type Type.\n   * @param {Collection<Feature>} features\n   * The features modified.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent\n   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, features, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The features being modified.\n     * @type {Collection<Feature>}\n     * @api\n     */\n    this.features = features;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for modifying feature geometries.  To modify features that have\n * been added to an existing source, construct the modify interaction with the\n * `source` option.  If you want to modify features in a collection (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.  The interaction must be constructed with either a\n * `source` or `features` option.\n *\n * Cartesian distance from the pointer is used to determine the features that\n * will be modified. This means that geometries will only be considered for\n * modification when they are within the configured `pixelTolerance`. For point\n * geometries, the `hitDetection` option can be used to match their visual\n * appearance.\n *\n * By default, the interaction will allow deletion of vertices when the `alt`\n * key is pressed.  To configure the interaction with a different condition\n * for deletion, use the `deleteCondition` option.\n * @fires ModifyEvent\n * @api\n */\nclass Modify extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {ModifyOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ModifyOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ModifyOnSignature<void>}\n     */\n    this.un;\n\n    /** @private */\n    this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : primaryAction;\n\n    /**\n     * @private\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\n     * @return {boolean} Combined condition result.\n     */\n    this.defaultDeleteCondition_ = function (mapBrowserEvent) {\n      return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);\n    };\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.deleteCondition_ = options.deleteCondition\n      ? options.deleteCondition\n      : this.defaultDeleteCondition_;\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.insertVertexCondition_ = options.insertVertexCondition\n      ? options.insertVertexCondition\n      : always;\n\n    /**\n     * Editing vertex.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.vertexFeature_ = null;\n\n    /**\n     * Segments intersecting {@link this.vertexFeature_} by segment uid.\n     * @type {Object<string, boolean>}\n     * @private\n     */\n    this.vertexSegments_ = null;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.lastPixel_ = [0, 0];\n\n    /**\n     * Tracks if the next `singleclick` event should be ignored to prevent\n     * accidental deletion right after vertex creation.\n     * @type {boolean}\n     * @private\n     */\n    this.ignoreNextSingleClick_ = false;\n\n    /**\n     * @type {Collection<Feature>}\n     * @private\n     */\n    this.featuresBeingModified_ = null;\n\n    /**\n     * Segment RTree for each layer\n     * @type {RBush<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.snappedToVertex_ = false;\n\n    /**\n     * Indicate whether the interaction is currently changing a feature's\n     * coordinates.\n     * @type {boolean}\n     * @private\n     */\n    this.changingFeature_ = false;\n\n    /**\n     * @type {Array}\n     * @private\n     */\n    this.dragSegments_ = [];\n\n    /**\n     * Draw overlay where sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * @const\n     * @private\n     * @type {!Object<string, function(Feature, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_.bind(this),\n      'LineString': this.writeLineStringGeometry_.bind(this),\n      'LinearRing': this.writeLineStringGeometry_.bind(this),\n      'Polygon': this.writePolygonGeometry_.bind(this),\n      'MultiPoint': this.writeMultiPointGeometry_.bind(this),\n      'MultiLineString': this.writeMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.writeMultiPolygonGeometry_.bind(this),\n      'Circle': this.writeCircleGeometry_.bind(this),\n      'GeometryCollection': this.writeGeometryCollectionGeometry_.bind(this),\n    };\n\n    /**\n     * @type {VectorSource}\n     * @private\n     */\n    this.source_ = null;\n\n    /**\n     * @type {boolean|import(\"../layer/BaseVector\").default}\n     * @private\n     */\n    this.hitDetection_ = null;\n\n    /** @type {Collection<Feature>} */\n    let features;\n    if (options.features) {\n      features = options.features;\n    } else if (options.source) {\n      this.source_ = options.source;\n      features = new Collection(this.source_.getFeatures());\n      this.source_.addEventListener(\n        VectorEventType.ADDFEATURE,\n        this.handleSourceAdd_.bind(this),\n      );\n      this.source_.addEventListener(\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceRemove_.bind(this),\n      );\n    }\n    if (!features) {\n      throw new Error(\n        'The modify interaction requires features, a source or a layer',\n      );\n    }\n    if (options.hitDetection) {\n      this.hitDetection_ = options.hitDetection;\n    }\n\n    /**\n     * @type {Collection<Feature>}\n     * @private\n     */\n    this.features_ = features;\n\n    this.features_.forEach(this.addFeature_.bind(this));\n    this.features_.addEventListener(\n      CollectionEventType.ADD,\n      this.handleFeatureAdd_.bind(this),\n    );\n    this.features_.addEventListener(\n      CollectionEventType.REMOVE,\n      this.handleFeatureRemove_.bind(this),\n    );\n\n    /**\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @private\n     */\n    this.lastPointerEvent_ = null;\n\n    /**\n     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.\n     * @type {Array<number>}\n     * @private\n     */\n    this.delta_ = [0, 0];\n\n    /**\n     * @private\n     */\n    this.snapToPointer_ =\n      options.snapToPointer === undefined\n        ? !this.hitDetection_\n        : options.snapToPointer;\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  addFeature_(feature) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const writer = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (writer) {\n        writer(feature, geometry);\n      }\n    }\n    const map = this.getMap();\n    if (map && map.isRendered() && this.getActive()) {\n      this.handlePointerAtPixel_(this.lastPixel_, map);\n    }\n    feature.addEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.\n   * @private\n   */\n  willModifyFeatures_(evt, segments) {\n    if (!this.featuresBeingModified_) {\n      this.featuresBeingModified_ = new Collection();\n      const features = this.featuresBeingModified_.getArray();\n      for (let i = 0, ii = segments.length; i < ii; ++i) {\n        const segment = segments[i];\n        for (let s = 0, ss = segment.length; s < ss; ++s) {\n          const feature = segment[s].feature;\n          if (feature && !features.includes(feature)) {\n            this.featuresBeingModified_.push(feature);\n          }\n        }\n      }\n      if (this.featuresBeingModified_.getLength() === 0) {\n        this.featuresBeingModified_ = null;\n      } else {\n        this.dispatchEvent(\n          new ModifyEvent(\n            ModifyEventType.MODIFYSTART,\n            this.featuresBeingModified_,\n            evt,\n          ),\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeature_(feature) {\n    this.removeFeatureSegmentData_(feature);\n    // Remove the vertex feature if the collection of candidate features is empty.\n    if (this.vertexFeature_ && this.features_.getLength() === 0) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n    feature.removeEventListener(\n      EventType.CHANGE,\n      this.boundHandleFeatureChange_,\n    );\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureSegmentData_(feature) {\n    const rBush = this.rBush_;\n    /** @type {Array<SegmentData>} */\n    const nodesToRemove = [];\n    rBush.forEach(\n      /**\n       * @param {SegmentData} node RTree node.\n       */\n      function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      },\n    );\n    for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n      const nodeToRemove = nodesToRemove[i];\n      for (let j = this.dragSegments_.length - 1; j >= 0; --j) {\n        if (this.dragSegments_[j][0] === nodeToRemove) {\n          this.dragSegments_.splice(j, 1);\n        }\n      }\n      rBush.remove(nodeToRemove);\n    }\n  }\n\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   * @override\n   */\n  setActive(active) {\n    if (this.vertexFeature_ && !active) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n    super.setActive(active);\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   * @override\n   */\n  setMap(map) {\n    this.overlay_.setMap(map);\n    super.setMap(map);\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders the modification point or vertex to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceAdd_(event) {\n    if (event.feature) {\n      this.features_.push(event.feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceRemove_(event) {\n    if (event.feature) {\n      this.features_.remove(event.feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    this.addFeature_(evt.element);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    if (!this.changingFeature_) {\n      const feature = /** @type {Feature} */ (evt.target);\n      this.removeFeature_(feature);\n      this.addFeature_(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    this.removeFeature_(evt.element);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {Point} geometry Geometry.\n   * @private\n   */\n  writePointGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n\n    /** @type {SegmentData} */\n    const segmentData = {\n      feature: feature,\n      geometry: geometry,\n      segment: [coordinates, coordinates],\n    };\n\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPointGeometry_(feature, geometry) {\n    const points = geometry.getCoordinates();\n    for (let i = 0, ii = points.length; i < ii; ++i) {\n      const coordinates = points[i];\n\n      /** @type {SegmentData} */\n      const segmentData = {\n        feature: feature,\n        geometry: geometry,\n        depth: [i],\n        index: i,\n        segment: [coordinates, coordinates],\n      };\n\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeLineStringGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n\n      /** @type {SegmentData} */\n      const segmentData = {\n        feature: feature,\n        geometry: geometry,\n        index: i,\n        segment: segment,\n      };\n\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiLineStringGeometry_(feature, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n\n        /** @type {SegmentData} */\n        const segmentData = {\n          feature: feature,\n          geometry: geometry,\n          depth: [j],\n          index: i,\n          segment: segment,\n        };\n\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writePolygonGeometry_(feature, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n\n        /** @type {SegmentData} */\n        const segmentData = {\n          feature: feature,\n          geometry: geometry,\n          depth: [j],\n          index: i,\n          segment: segment,\n        };\n\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPolygonGeometry_(feature, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          const segment = coordinates.slice(i, i + 2);\n\n          /** @type {SegmentData} */\n          const segmentData = {\n            feature: feature,\n            geometry: geometry,\n            depth: [j, k],\n            index: i,\n            segment: segment,\n          };\n\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  }\n\n  /**\n   * We convert a circle into two segments.  The segment at index\n   * {@link CIRCLE_CENTER_INDEX} is the\n   * circle's center (a point).  The segment at index\n   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is\n   * the circumference, and is not a line segment.\n   *\n   * @param {Feature} feature Feature.\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  writeCircleGeometry_(feature, geometry) {\n    const coordinates = geometry.getCenter();\n\n    /** @type {SegmentData} */\n    const centerSegmentData = {\n      feature: feature,\n      geometry: geometry,\n      index: CIRCLE_CENTER_INDEX,\n      segment: [coordinates, coordinates],\n    };\n\n    /** @type {SegmentData} */\n    const circumferenceSegmentData = {\n      feature: feature,\n      geometry: geometry,\n      index: CIRCLE_CIRCUMFERENCE_INDEX,\n      segment: [coordinates, coordinates],\n    };\n\n    const featureSegments = [centerSegmentData, circumferenceSegmentData];\n    centerSegmentData.featureSegments = featureSegments;\n    circumferenceSegmentData.featureSegments = featureSegments;\n    this.rBush_.insert(createExtent(coordinates), centerSegmentData);\n    let circleGeometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\n      geometry\n    );\n    const userProjection = getUserProjection();\n    if (userProjection && this.getMap()) {\n      const projection = this.getMap().getView().getProjection();\n      circleGeometry = circleGeometry\n        .clone()\n        .transform(userProjection, projection);\n      circleGeometry = fromCircle(\n        /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry),\n      ).transform(projection, userProjection);\n    }\n    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  writeGeometryCollectionGeometry_(feature, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const geometry = geometries[i];\n      const writer = this.SEGMENT_WRITERS_[geometry.getType()];\n      writer(feature, geometry);\n    }\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n   * @param {Array<Feature>} features The features being modified.\n   * @param {Array<import(\"../geom/SimpleGeometry.js\").default>} geometries The geometries being modified.\n   * @return {Feature} Vertex feature.\n   * @private\n   */\n  createOrUpdateVertexFeature_(coordinates, features, geometries) {\n    let vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      vertexFeature = new Feature(new Point(coordinates));\n      this.vertexFeature_ = vertexFeature;\n      this.overlay_.getSource().addFeature(vertexFeature);\n    } else {\n      const geometry = vertexFeature.getGeometry();\n      geometry.setCoordinates(coordinates);\n    }\n    vertexFeature.set('features', features);\n    vertexFeature.set('geometries', geometries);\n    return vertexFeature;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @override\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent) {\n      return true;\n    }\n    this.lastPointerEvent_ = mapBrowserEvent;\n\n    let handled;\n    if (\n      !mapBrowserEvent.map.getView().getInteracting() &&\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\n      !this.handlingDownUpSequence\n    ) {\n      this.handlePointerMove_(mapBrowserEvent);\n    }\n    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {\n      if (\n        mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK ||\n        !this.ignoreNextSingleClick_\n      ) {\n        handled = this.removePoint();\n      } else {\n        handled = true;\n      }\n    }\n\n    if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {\n      this.ignoreNextSingleClick_ = false;\n    }\n\n    return super.handleEvent(mapBrowserEvent) && !handled;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @override\n   */\n  handleDragEvent(evt) {\n    this.ignoreNextSingleClick_ = false;\n    this.willModifyFeatures_(evt, this.dragSegments_);\n\n    const vertex = [\n      evt.coordinate[0] + this.delta_[0],\n      evt.coordinate[1] + this.delta_[1],\n    ];\n    const features = [];\n    const geometries = [];\n    for (let i = 0, ii = this.dragSegments_.length; i < ii; ++i) {\n      const dragSegment = this.dragSegments_[i];\n      const segmentData = dragSegment[0];\n      const feature = segmentData.feature;\n      if (!features.includes(feature)) {\n        features.push(feature);\n      }\n      const geometry = segmentData.geometry;\n      if (!geometries.includes(geometry)) {\n        geometries.push(geometry);\n      }\n      const depth = segmentData.depth;\n      let coordinates;\n      const segment = segmentData.segment;\n      const index = dragSegment[1];\n\n      while (vertex.length < geometry.getStride()) {\n        vertex.push(segment[index][vertex.length]);\n      }\n\n      switch (geometry.getType()) {\n        case 'Point':\n          coordinates = vertex;\n          segment[0] = vertex;\n          segment[1] = vertex;\n          break;\n        case 'MultiPoint':\n          coordinates = geometry.getCoordinates();\n          coordinates[segmentData.index] = vertex;\n          segment[0] = vertex;\n          segment[1] = vertex;\n          break;\n        case 'LineString':\n          coordinates = geometry.getCoordinates();\n          coordinates[segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'MultiLineString':\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'Polygon':\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'MultiPolygon':\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'Circle':\n          segment[0] = vertex;\n          segment[1] = vertex;\n          if (segmentData.index === CIRCLE_CENTER_INDEX) {\n            this.changingFeature_ = true;\n            geometry.setCenter(vertex);\n            this.changingFeature_ = false;\n          } else {\n            // We're dragging the circle's circumference:\n            this.changingFeature_ = true;\n            const projection = evt.map.getView().getProjection();\n            let radius = coordinateDistance(\n              fromUserCoordinate(geometry.getCenter(), projection),\n              fromUserCoordinate(vertex, projection),\n            );\n            const userProjection = getUserProjection();\n            if (userProjection) {\n              const circleGeometry = geometry\n                .clone()\n                .transform(userProjection, projection);\n              circleGeometry.setRadius(radius);\n              radius = circleGeometry\n                .transform(projection, userProjection)\n                .getRadius();\n            }\n            geometry.setRadius(radius);\n            this.changingFeature_ = false;\n          }\n          break;\n        default:\n        // pass\n      }\n\n      if (coordinates) {\n        this.setGeometryCoordinates_(geometry, coordinates);\n      }\n    }\n    this.createOrUpdateVertexFeature_(vertex, features, geometries);\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleDownEvent(evt) {\n    if (!this.condition_(evt)) {\n      return false;\n    }\n    const pixelCoordinate = evt.coordinate;\n    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);\n    this.dragSegments_.length = 0;\n    this.featuresBeingModified_ = null;\n    const vertexFeature = this.vertexFeature_;\n    if (vertexFeature) {\n      const projection = evt.map.getView().getProjection();\n      const insertVertices = [];\n      const vertex = vertexFeature.getGeometry().getCoordinates();\n      const vertexExtent = boundingExtent([vertex]);\n      const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\n      const componentSegments = {};\n      segmentDataMatches.sort(compareIndexes);\n      for (let i = 0, ii = segmentDataMatches.length; i < ii; ++i) {\n        const segmentDataMatch = segmentDataMatches[i];\n        const segment = segmentDataMatch.segment;\n        let uid = getUid(segmentDataMatch.geometry);\n        const depth = segmentDataMatch.depth;\n        if (depth) {\n          uid += '-' + depth.join('-'); // separate feature components\n        }\n        if (!componentSegments[uid]) {\n          componentSegments[uid] = new Array(2);\n        }\n\n        if (\n          segmentDataMatch.geometry.getType() === 'Circle' &&\n          segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX\n        ) {\n          const closestVertex = closestOnSegmentData(\n            pixelCoordinate,\n            segmentDataMatch,\n            projection,\n          );\n          if (\n            coordinatesEqual(closestVertex, vertex) &&\n            !componentSegments[uid][0]\n          ) {\n            this.dragSegments_.push([segmentDataMatch, 0]);\n            componentSegments[uid][0] = segmentDataMatch;\n          }\n          continue;\n        }\n\n        if (\n          coordinatesEqual(segment[0], vertex) &&\n          !componentSegments[uid][0]\n        ) {\n          this.dragSegments_.push([segmentDataMatch, 0]);\n          componentSegments[uid][0] = segmentDataMatch;\n          continue;\n        }\n\n        if (\n          coordinatesEqual(segment[1], vertex) &&\n          !componentSegments[uid][1]\n        ) {\n          if (\n            componentSegments[uid][0] &&\n            componentSegments[uid][0].index === 0\n          ) {\n            let coordinates = segmentDataMatch.geometry.getCoordinates();\n            switch (segmentDataMatch.geometry.getType()) {\n              // prevent dragging closed linestrings by the connecting node\n              case 'LineString':\n              case 'MultiLineString':\n                continue;\n              // if dragging the first vertex of a polygon, ensure the other segment\n              // belongs to the closing vertex of the linear ring\n              case 'MultiPolygon':\n                coordinates = coordinates[depth[1]];\n              /* falls through */\n              case 'Polygon':\n                if (\n                  segmentDataMatch.index !==\n                  coordinates[depth[0]].length - 2\n                ) {\n                  continue;\n                }\n                break;\n              default:\n              // pass\n            }\n          }\n\n          this.dragSegments_.push([segmentDataMatch, 1]);\n          componentSegments[uid][1] = segmentDataMatch;\n          continue;\n        }\n\n        if (\n          getUid(segment) in this.vertexSegments_ &&\n          !componentSegments[uid][0] &&\n          !componentSegments[uid][1] &&\n          this.insertVertexCondition_(evt)\n        ) {\n          insertVertices.push(segmentDataMatch);\n        }\n      }\n\n      if (insertVertices.length) {\n        this.willModifyFeatures_(evt, [insertVertices]);\n      }\n\n      for (let j = insertVertices.length - 1; j >= 0; --j) {\n        this.insertVertex_(insertVertices[j], vertex);\n      }\n    }\n    return !!this.vertexFeature_;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(evt) {\n    for (let i = this.dragSegments_.length - 1; i >= 0; --i) {\n      const segmentData = this.dragSegments_[i][0];\n      const geometry = segmentData.geometry;\n      if (geometry.getType() === 'Circle') {\n        // Update a circle object in the R* bush:\n        const coordinates = geometry.getCenter();\n        const centerSegmentData = segmentData.featureSegments[0];\n        const circumferenceSegmentData = segmentData.featureSegments[1];\n        centerSegmentData.segment[0] = coordinates;\n        centerSegmentData.segment[1] = coordinates;\n        circumferenceSegmentData.segment[0] = coordinates;\n        circumferenceSegmentData.segment[1] = coordinates;\n        this.rBush_.update(createExtent(coordinates), centerSegmentData);\n        let circleGeometry = geometry;\n        const userProjection = getUserProjection();\n        if (userProjection) {\n          const projection = evt.map.getView().getProjection();\n          circleGeometry = circleGeometry\n            .clone()\n            .transform(userProjection, projection);\n          circleGeometry = fromCircle(circleGeometry).transform(\n            projection,\n            userProjection,\n          );\n        }\n        this.rBush_.update(\n          circleGeometry.getExtent(),\n          circumferenceSegmentData,\n        );\n      } else {\n        this.rBush_.update(boundingExtent(segmentData.segment), segmentData);\n      }\n    }\n    if (this.featuresBeingModified_) {\n      this.dispatchEvent(\n        new ModifyEvent(\n          ModifyEventType.MODIFYEND,\n          this.featuresBeingModified_,\n          evt,\n        ),\n      );\n      this.featuresBeingModified_ = null;\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @private\n   */\n  handlePointerMove_(evt) {\n    this.lastPixel_ = evt.pixel;\n    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../Map.js\").default} map Map.\n   * @param {import(\"../coordinate.js\").Coordinate} [coordinate] The pixel Coordinate.\n   * @private\n   */\n  handlePointerAtPixel_(pixel, map, coordinate) {\n    const pixelCoordinate = coordinate || map.getCoordinateFromPixel(pixel);\n    const projection = map.getView().getProjection();\n    const sortByDistance = function (a, b) {\n      return (\n        projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) -\n        projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection)\n      );\n    };\n\n    /** @type {Array<SegmentData>|undefined} */\n    let nodes;\n    /** @type {Point|undefined} */\n    let hitPointGeometry;\n    if (this.hitDetection_) {\n      const layerFilter =\n        typeof this.hitDetection_ === 'object'\n          ? (layer) => layer === this.hitDetection_\n          : undefined;\n      map.forEachFeatureAtPixel(\n        pixel,\n        (feature, layer, geometry) => {\n          if (geometry && geometry.getType() === 'Point') {\n            geometry = new Point(\n              toUserCoordinate(geometry.getCoordinates(), projection),\n            );\n          }\n          const geom = geometry || feature.getGeometry();\n          if (\n            feature instanceof Feature &&\n            this.features_.getArray().includes(feature)\n          ) {\n            hitPointGeometry = /** @type {Point} */ (geom);\n            const coordinate = /** @type {Point} */ (feature.getGeometry())\n              .getFlatCoordinates()\n              .slice(0, 2);\n            nodes = [\n              {\n                feature,\n                geometry: hitPointGeometry,\n                segment: [coordinate, coordinate],\n              },\n            ];\n          }\n          return true;\n        },\n        {layerFilter},\n      );\n    }\n    if (!nodes) {\n      const viewExtent = fromUserExtent(\n        createExtent(pixelCoordinate, tempExtent),\n        projection,\n      );\n      const buffer = map.getView().getResolution() * this.pixelTolerance_;\n      const box = toUserExtent(\n        bufferExtent(viewExtent, buffer, tempExtent),\n        projection,\n      );\n      nodes = this.rBush_.getInExtent(box);\n    }\n\n    if (nodes && nodes.length > 0) {\n      const node = nodes.sort(sortByDistance)[0];\n      const closestSegment = node.segment;\n      let vertex = closestOnSegmentData(pixelCoordinate, node, projection);\n      const vertexPixel = map.getPixelFromCoordinate(vertex);\n      let dist = coordinateDistance(pixel, vertexPixel);\n      if (hitPointGeometry || dist <= this.pixelTolerance_) {\n        /** @type {Object<string, boolean>} */\n        const vertexSegments = {};\n        vertexSegments[getUid(closestSegment)] = true;\n\n        if (!this.snapToPointer_) {\n          this.delta_[0] = vertex[0] - pixelCoordinate[0];\n          this.delta_[1] = vertex[1] - pixelCoordinate[1];\n        }\n        if (\n          node.geometry.getType() === 'Circle' &&\n          node.index === CIRCLE_CIRCUMFERENCE_INDEX\n        ) {\n          this.snappedToVertex_ = true;\n          this.createOrUpdateVertexFeature_(\n            vertex,\n            [node.feature],\n            [node.geometry],\n          );\n        } else {\n          const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n          const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n          const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n          const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n          this.snappedToVertex_ = dist <= this.pixelTolerance_;\n          if (this.snappedToVertex_) {\n            vertex =\n              squaredDist1 > squaredDist2\n                ? closestSegment[1]\n                : closestSegment[0];\n          }\n          this.createOrUpdateVertexFeature_(\n            vertex,\n            [node.feature],\n            [node.geometry],\n          );\n          const geometries = {};\n          geometries[getUid(node.geometry)] = true;\n          for (let i = 1, ii = nodes.length; i < ii; ++i) {\n            const segment = nodes[i].segment;\n            if (\n              (coordinatesEqual(closestSegment[0], segment[0]) &&\n                coordinatesEqual(closestSegment[1], segment[1])) ||\n              (coordinatesEqual(closestSegment[0], segment[1]) &&\n                coordinatesEqual(closestSegment[1], segment[0]))\n            ) {\n              const geometryUid = getUid(nodes[i].geometry);\n              if (!(geometryUid in geometries)) {\n                geometries[geometryUid] = true;\n                vertexSegments[getUid(segment)] = true;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        this.vertexSegments_ = vertexSegments;\n        return;\n      }\n    }\n    if (this.vertexFeature_) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n  }\n\n  /**\n   * @param {SegmentData} segmentData Segment data.\n   * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n   * @private\n   */\n  insertVertex_(segmentData, vertex) {\n    const segment = segmentData.segment;\n    const feature = segmentData.feature;\n    const geometry = segmentData.geometry;\n    const depth = segmentData.depth;\n    const index = segmentData.index;\n    let coordinates;\n\n    while (vertex.length < geometry.getStride()) {\n      vertex.push(0);\n    }\n\n    switch (geometry.getType()) {\n      case 'MultiLineString':\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case 'Polygon':\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case 'MultiPolygon':\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case 'LineString':\n        coordinates = geometry.getCoordinates();\n        coordinates.splice(index + 1, 0, vertex);\n        break;\n      default:\n        return;\n    }\n\n    this.setGeometryCoordinates_(geometry, coordinates);\n    const rTree = this.rBush_;\n    rTree.remove(segmentData);\n    this.updateSegmentIndices_(geometry, index, depth, 1);\n\n    /** @type {SegmentData} */\n    const newSegmentData = {\n      segment: [segment[0], vertex],\n      feature: feature,\n      geometry: geometry,\n      depth: depth,\n      index: index,\n    };\n\n    rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);\n    this.dragSegments_.push([newSegmentData, 1]);\n\n    /** @type {SegmentData} */\n    const newSegmentData2 = {\n      segment: [vertex, segment[1]],\n      feature: feature,\n      geometry: geometry,\n      depth: depth,\n      index: index + 1,\n    };\n\n    rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);\n    this.dragSegments_.push([newSegmentData2, 0]);\n    this.ignoreNextSingleClick_ = true;\n  }\n\n  /**\n   * Removes the vertex currently being pointed.\n   * @return {boolean} True when a vertex was removed.\n   * @api\n   */\n  removePoint() {\n    if (\n      this.lastPointerEvent_ &&\n      this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG\n    ) {\n      const evt = this.lastPointerEvent_;\n      this.willModifyFeatures_(evt, this.dragSegments_);\n      const removed = this.removeVertex_();\n      if (this.featuresBeingModified_) {\n        this.dispatchEvent(\n          new ModifyEvent(\n            ModifyEventType.MODIFYEND,\n            this.featuresBeingModified_,\n            evt,\n          ),\n        );\n      }\n\n      this.featuresBeingModified_ = null;\n      return removed;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a vertex from all matching features.\n   * @return {boolean} True when a vertex was removed.\n   * @private\n   */\n  removeVertex_() {\n    const dragSegments = this.dragSegments_;\n    const segmentsByFeature = {};\n    let deleted = false;\n    let component, coordinates, dragSegment, geometry, i, index, left;\n    let newIndex, right, segmentData, uid;\n    for (i = dragSegments.length - 1; i >= 0; --i) {\n      dragSegment = dragSegments[i];\n      segmentData = dragSegment[0];\n      uid = getUid(segmentData.feature);\n      if (segmentData.depth) {\n        // separate feature components\n        uid += '-' + segmentData.depth.join('-');\n      }\n      if (!(uid in segmentsByFeature)) {\n        segmentsByFeature[uid] = {};\n      }\n      if (dragSegment[1] === 0) {\n        segmentsByFeature[uid].right = segmentData;\n        segmentsByFeature[uid].index = segmentData.index;\n      } else if (dragSegment[1] == 1) {\n        segmentsByFeature[uid].left = segmentData;\n        segmentsByFeature[uid].index = segmentData.index + 1;\n      }\n    }\n    for (uid in segmentsByFeature) {\n      right = segmentsByFeature[uid].right;\n      left = segmentsByFeature[uid].left;\n      index = segmentsByFeature[uid].index;\n      newIndex = index - 1;\n      if (left !== undefined) {\n        segmentData = left;\n      } else {\n        segmentData = right;\n      }\n      if (newIndex < 0) {\n        newIndex = 0;\n      }\n      geometry = segmentData.geometry;\n      coordinates = geometry.getCoordinates();\n      component = coordinates;\n      deleted = false;\n      switch (geometry.getType()) {\n        case 'MultiLineString':\n          if (coordinates[segmentData.depth[0]].length > 2) {\n            coordinates[segmentData.depth[0]].splice(index, 1);\n            deleted = true;\n          }\n          break;\n        case 'LineString':\n          if (coordinates.length > 2) {\n            coordinates.splice(index, 1);\n            deleted = true;\n          }\n          break;\n        case 'MultiPolygon':\n          component = component[segmentData.depth[1]];\n        /* falls through */\n        case 'Polygon':\n          component = component[segmentData.depth[0]];\n          if (component.length > 4) {\n            if (index == component.length - 1) {\n              index = 0;\n            }\n            component.splice(index, 1);\n            deleted = true;\n            if (index === 0) {\n              // close the ring again\n              component.pop();\n              component.push(component[0]);\n              newIndex = component.length - 1;\n            }\n          }\n          break;\n        default:\n        // pass\n      }\n\n      if (deleted) {\n        this.setGeometryCoordinates_(geometry, coordinates);\n        const segments = [];\n        if (left !== undefined) {\n          this.rBush_.remove(left);\n          segments.push(left.segment[0]);\n        }\n        if (right !== undefined) {\n          this.rBush_.remove(right);\n          segments.push(right.segment[1]);\n        }\n        if (left !== undefined && right !== undefined) {\n          /** @type {SegmentData} */\n          const newSegmentData = {\n            depth: segmentData.depth,\n            feature: segmentData.feature,\n            geometry: segmentData.geometry,\n            index: newIndex,\n            segment: segments,\n          };\n\n          this.rBush_.insert(\n            boundingExtent(newSegmentData.segment),\n            newSegmentData,\n          );\n        }\n        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);\n        if (this.vertexFeature_) {\n          this.overlay_.getSource().removeFeature(this.vertexFeature_);\n          this.vertexFeature_ = null;\n        }\n        dragSegments.length = 0;\n      }\n    }\n    return deleted;\n  }\n\n  /**\n   * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {Array} coordinates Coordinates.\n   * @private\n   */\n  setGeometryCoordinates_(geometry, coordinates) {\n    this.changingFeature_ = true;\n    geometry.setCoordinates(coordinates);\n    this.changingFeature_ = false;\n  }\n\n  /**\n   * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {number} index Index.\n   * @param {Array<number>|undefined} depth Depth.\n   * @param {number} delta Delta (1 or -1).\n   * @private\n   */\n  updateSegmentIndices_(geometry, index, depth, delta) {\n    this.rBush_.forEachInExtent(\n      geometry.getExtent(),\n      function (segmentDataMatch) {\n        if (\n          segmentDataMatch.geometry === geometry &&\n          (depth === undefined ||\n            segmentDataMatch.depth === undefined ||\n            equals(segmentDataMatch.depth, depth)) &&\n          segmentDataMatch.index > index\n        ) {\n          segmentDataMatch.index += delta;\n        }\n      },\n    );\n  }\n}\n\n/**\n * @param {SegmentData} a The first segment data.\n * @param {SegmentData} b The second segment data.\n * @return {number} The difference in indexes.\n */\nfunction compareIndexes(a, b) {\n  return a.index - b.index;\n}\n\n/**\n * Returns the distance from a point to a line segment.\n *\n * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The coordinates of the point from\n *        which to calculate the distance.\n * @param {SegmentData} segmentData The object describing the line\n *        segment we are calculating the distance to.\n * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n * @return {number} The square of the distance between a point and a line segment.\n */\nfunction projectedDistanceToSegmentDataSquared(\n  pointCoordinates,\n  segmentData,\n  projection,\n) {\n  const geometry = segmentData.geometry;\n\n  if (geometry.getType() === 'Circle') {\n    let circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n      geometry\n    );\n\n    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        circleGeometry = circleGeometry\n          .clone()\n          .transform(userProjection, projection);\n      }\n      const distanceToCenterSquared = squaredCoordinateDistance(\n        circleGeometry.getCenter(),\n        fromUserCoordinate(pointCoordinates, projection),\n      );\n      const distanceToCircumference =\n        Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();\n      return distanceToCircumference * distanceToCircumference;\n    }\n  }\n\n  const coordinate = fromUserCoordinate(pointCoordinates, projection);\n  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\n  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\n  return squaredDistanceToSegment(coordinate, tempSegment);\n}\n\n/**\n * Returns the point closest to a given line segment.\n *\n * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The point to which a closest point\n *        should be found.\n * @param {SegmentData} segmentData The object describing the line\n *        segment which should contain the closest point.\n * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n * @return {import(\"../coordinate.js\").Coordinate} The point closest to the specified line segment.\n */\nfunction closestOnSegmentData(pointCoordinates, segmentData, projection) {\n  const geometry = segmentData.geometry;\n\n  if (\n    geometry.getType() === 'Circle' &&\n    segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX\n  ) {\n    let circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n      geometry\n    );\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = circleGeometry\n        .clone()\n        .transform(userProjection, projection);\n    }\n    return toUserCoordinate(\n      circleGeometry.getClosestPoint(\n        fromUserCoordinate(pointCoordinates, projection),\n      ),\n      projection,\n    );\n  }\n  const coordinate = fromUserCoordinate(pointCoordinates, projection);\n  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\n  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\n  return toUserCoordinate(\n    closestOnSegment(coordinate, tempSegment),\n    projection,\n  );\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Point'];\n  };\n}\n\nexport default Modify;\n","import React from 'react';\nimport 'ol/ol.css';\nimport TileLayer from 'ol/layer/Tile';\nimport { OSM } from 'ol/source.js';\nimport VectorSource from 'ol/source/Vector';\nimport { GeoJSON } from 'ol/format';\nimport { Pointer, Modify, Select, Draw, defaults } from 'ol/interaction.js';\nimport { click, platformModifierKeyOnly } from 'ol/events/condition';\nimport View from 'ol/View.js';\nimport Map$1 from 'ol/Map';\nimport { DoubleClickZoom, DragBox } from 'ol/interaction';\nimport { SimpleGeometry } from 'ol/geom';\nimport VectorLayer from 'ol/layer/Vector';\nimport { Style, Fill, Stroke, Circle } from 'ol/style';\nimport * as extent from 'ol/extent';\nimport { createRoot } from 'react-dom/client';\n\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n    return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n  return getRandomValues(rnds8);\n}\n\nvar randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nvar native = {\n  randomUUID\n};\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n  return unsafeStringify(rnds);\n}\n\nfunction handleDownEvent(evt) {\n    const run=evt.activePointers[0]?.shiftKey=== true&&evt.activePointers[0]?.ctrlKey===true;\n    if (!run) {\n        return null;\n    }\n    const map = evt.map;\n    const feature = map.forEachFeatureAtPixel(evt.pixel, function (feature) {\n        return feature;\n    });\n\n    if (feature) {\n\n        this.coordinate_ = evt.coordinate;\n        this.feature_ = feature;\n    }\n\n    return !!feature;\n}\n\nfunction handleDragEvent(evt) {\n\n    const deltaX = evt.coordinate[0] - this.coordinate_[0];\n    const deltaY = evt.coordinate[1] - this.coordinate_[1];\n\n    const geometry = this.feature_.getGeometry();\n    geometry.translate(deltaX, deltaY);\n\n    this.coordinate_[0] = evt.coordinate[0];\n    this.coordinate_[1] = evt.coordinate[1];\n    this.drag_ = 1;\n\n\n}\n\nfunction handleUpEvent() {\n    if (this.drag_) {\n        if (this.option.onDragEnd) {\n            this.option.onDragEnd(this.bsrMap, this.feature_);\n        }\n    }\n    this.drag_ = null;\n    this.coordinate_ = null;\n    this.feature_ = null;\n    return false;\n}\n\nfunction handleMoveEvent(evt) {\n\n    if (this.cursor_) {\n        const map = evt.map;\n        const feature = map.forEachFeatureAtPixel(evt.pixel, function (feature) {\n            return feature;\n        });\n        const element = evt.map.getTargetElement();\n        if (feature) {\n\n            if (element.style.cursor !== this.cursor_) {\n                this.previousCursor_ = element.style.cursor;\n                element.style.cursor = this.cursor_;\n            }\n        } else if (this.previousCursor_ !== undefined) {\n            element.style.cursor = this.previousCursor_;\n            this.previousCursor_ = undefined;\n        }\n    }\n}\n\nclass Drag extends Pointer {\n    constructor(bsrMap, option) {\n        super({\n            handleDownEvent: handleDownEvent,\n            handleDragEvent: handleDragEvent,\n            handleMoveEvent: handleMoveEvent,\n            handleUpEvent: handleUpEvent,\n        });\n        this.bsrMap = bsrMap;\n        this.option = option;\n        this.coordinate_ = null;\n        this.cursor_ = 'pointer';\n        this.feature_ = null;\n        this.drag_ = null;\n        this.previousCursor_ = undefined;\n    }\n}\n\nclass StyleOsm {\n\n    constructor(option) {\n        this.option = option;\n        this.styles = {};\n        this.stylesSelect = undefined;\n        this.refreshStyleSettings();\n    }\n    refreshStyleSettings(){\n        this.stylesSelect = new Style({\n            fill: new Fill({\n                color: this.hexToRgbAEx(this.option.style?.fillBodySelect ?? '#F8F9F4'),\n            }),\n            stroke: new Stroke({\n                color: this.option.style?.colorLineSelect ?? '#f80622',\n                width: this.option.style?.widthLineSelect ?? 3\n            }),\n            image: new Circle({\n                radius: this.option.style?.radiusPointSelect??6,\n                fill: new Fill({\n                    color: this.option.style?.colorPointSelect ?? '#b91818',\n                })\n            })\n        });\n        this.styles={\n\n            'LineString': new Style({\n                fill: new Fill({\n                    color: 'rgb(167,81,81)'\n                }),\n                stroke: new Stroke({\n                    color: this.option.style?.colorLineString ?? '#179a1c',\n                    width: this.option.style?.widthLineString ?? 4\n                }),\n                image: new Circle({\n                    radius: 7,\n                    fill: new Fill({\n                        color: '#ffcc33'\n                    })\n                })\n            }),\n            'Polygon': new Style({\n                fill: new Fill({\n                    color: this.hexToRgbAEx(this.option.style?.fillPolygon ?? '#F8F9F4'),\n                }),\n                stroke: new Stroke({\n                    color: this.option.style?.colorPolygon ?? '#07720d',\n                    width: this.option.style?.widthPolygon ?? 3\n                }),\n                image: new Circle({\n                    radius: 7,\n                    fill: new Fill({\n                        color: '#ffcc33'\n                    })\n                })\n            }),\n            'Circle': new Style({\n                fill: new Fill({\n                    color: this.hexToRgbAEx(this.option.style?.fillCircle??'#dd2e2e')\n                }),\n                stroke: new Stroke({\n                    color: this.option.style?.colorCircle??'#24f22e',\n                    width: this.option.style?.widthCircle??5\n                }),\n\n            }),\n\n            'Point': new Style({\n                image: new Circle({\n                    radius: this.option.style?.radiusPoint??5,\n                    fill: new Fill({\n                        color: this.option.style?.colorPoint??'#0324fb'\n                    })\n                })\n            }),\n\n        };\n    }\n\n    styleFunction = (feature) => {\n        return this.styles[feature.getGeometry().getType()];\n    }\n\n    selectStyle=()=> {\n        return this.stylesSelect\n    }\n\n\n\n\n    hexToRgbAEx(color){\n        const hex=color;\n        let c;\n        if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){\n            c= hex.substring(1).split('');\n            if(c.length=== 3){\n                c= [c[0], c[0], c[1], c[1], c[2], c[2]];\n            }\n            c= '0x'+c.join('');\n            return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+',0.2)';\n        }\n        throw new Error('Bad Hex');\n    }\n}\n\nvar bsrMap$1 = 'bsr-12';\nfunction parse(hash) {\n    if (!hash) {\n        return undefined;\n    }\n    var parts = hash.split('/');\n    if (parts.length === 4) {\n        return {\n            zoom: parseFloat(parts[0]),\n            center: [parseFloat(parts[1]), parseFloat(parts[2])],\n            rotation: parseFloat(parts[3])\n        };\n    }\n    return undefined;\n}\nfunction GetPosition(option, id) {\n    var _a, _b, _c, _d;\n    var zoom = (_a = option.zoom) !== null && _a !== void 0 ? _a : 12;\n    var p = [348869.291502072, 5197452.410915278];\n    if (option.projection === \"EPSG:4326\") {\n        p = [0, 0];\n    }\n    var center = (_b = option.center) !== null && _b !== void 0 ? _b : p;\n    var rotation = (_c = option.rotation) !== null && _c !== void 0 ? _c : 0;\n    if (option.useSynchronizationUrl) {\n        var myUrl = new URLSearchParams(window.location.hash.substring(1));\n        var tag = myUrl.get(\"map\");\n        if (tag) {\n            var res = parse(tag);\n            if (res) {\n                return res;\n            }\n        }\n        else {\n            if (option.useSynchronizationUrl) {\n                var hashMap = getCookie((_d = bsrMap$1 + id) !== null && _d !== void 0 ? _d : '');\n                if (hashMap) {\n                    var res = parse(hashMap);\n                    if (res) {\n                        return res;\n                    }\n                }\n            }\n        }\n    }\n    return { zoom: zoom, center: center, rotation: rotation };\n}\nfunction setCookie(name, value) {\n    document.cookie = \"\".concat(name, \"=\").concat(value, \"; max-age=25920000\");\n}\n// function deleteCookie(name: string) {\n//     document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT`\n// }\nfunction getCookie(name) {\n    var matches = document.cookie.match(new RegExp(\"(?:^|; )\".concat(name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1'), \"=([^;]*)\")));\n    return matches ? decodeURIComponent(matches[1]) : undefined;\n}\n\nvar MapEventEditing = /** @class */ (function () {\n    function MapEventEditing() {\n        this.eventMap = new Map();\n    }\n    return MapEventEditing;\n}());\nvar MapEventCreated = /** @class */ (function () {\n    function MapEventCreated() {\n        this.eventMap = new Map();\n    }\n    return MapEventCreated;\n}());\n\nvar bsrMap = 'bsr-12';\nvar shouldUpdate = true;\nvar SyncUrl2 = /** @class */ (function () {\n    function SyncUrl2(map, option, id) {\n        var _this = this;\n        this.popState = function () {\n            shouldUpdate = false;\n            var myUrl = new URLSearchParams(window.location.hash.substring(1));\n            var hashMap = myUrl.get(\"map\");\n            if (hashMap) {\n                var res = parse(hashMap);\n                if (res) {\n                    var view = _this.map.getView();\n                    view.setCenter(res.center);\n                    view.setZoom(res.zoom);\n                    view.setRotation(res.rotation);\n                    var state = {\n                        zoom: view.getZoom(),\n                        center: view.getCenter(),\n                        rotation: view.getRotation(),\n                    };\n                    window.history.replaceState(state, 'map', window.location.hash);\n                }\n            }\n        };\n        this.getHashCore = function (hashMap) {\n            var hashNew = new URLSearchParams(window.location.hash.substring(1));\n            var str = '/#';\n            var iaAppendMap = false;\n            hashNew.forEach(function (value, name) {\n                if (name !== 'map') {\n                    if (str === '/#') {\n                        str = str + name + '=' + value;\n                    }\n                    else {\n                        str = str + \"&\" + name + '=' + value;\n                    }\n                }\n                else {\n                    iaAppendMap = true;\n                    if (str === '/#') {\n                        str = str + 'map=' + hashMap;\n                    }\n                    else {\n                        str = str + '&map=' + hashMap;\n                    }\n                }\n            });\n            if (!iaAppendMap) {\n                if (str === '/#') {\n                    str = str + \"map=\" + hashMap;\n                }\n                else {\n                    str = str + '&map=' + hashMap;\n                }\n            }\n            return str;\n        };\n        this.updatePermalink = function () {\n            var _a;\n            if (!shouldUpdate) {\n                shouldUpdate = true;\n                return;\n            }\n            var view = _this.map.getView();\n            var center = view.getCenter();\n            var hash = '' +\n                view.getZoom().toFixed(2) +\n                '/' +\n                center[0].toFixed(2) +\n                '/' +\n                center[1].toFixed(2) +\n                '/' +\n                view.getRotation();\n            var state = {\n                zoom: view.getZoom(),\n                center: view.getCenter(),\n                rotation: view.getRotation(),\n            };\n            setCookie((_a = bsrMap + _this.id) !== null && _a !== void 0 ? _a : '', hash);\n            window.history.pushState(state, 'map', _this.getHashCore(hash));\n        };\n        this.pp23 = function (event) {\n            if (event.state === null) {\n                return;\n            }\n            _this.map.getView().setCenter(event.state.center);\n            _this.map.getView().setZoom(event.state.zoom);\n            _this.map.getView().setRotation(event.state.rotation);\n            shouldUpdate = false;\n        };\n        this.Dispose = function () {\n            window.removeEventListener('popstate', _this.pp23);\n            //window.removeEventListener(\"hashchange\", this.popState);\n        };\n        this.map = map;\n        this.option = option;\n        this.id = id;\n        this.map.on('moveend', this.updatePermalink);\n        window.addEventListener('popstate', this.pp23.bind(this));\n        window.addEventListener(\"hashchange\", this.popState.bind(this));\n    }\n    return SyncUrl2;\n}());\n\nvar BsrMap = /** @class */ (function (_super) {\n    __extends(BsrMap, _super);\n    function BsrMap(props) {\n        var _this = this;\n        var _a;\n        _this = _super.call(this, props) || this;\n        _this.mapEventEntEdit = new MapEventEditing();\n        _this.mapEventCreated = new MapEventCreated();\n        _this.isEdit = false;\n        _this.isCreate = false;\n        _this.isDispose = false;\n        _this.refDivMap = React.createRef();\n        _this.option = (_a = _this.props.option) !== null && _a !== void 0 ? _a : {};\n        _this.id = v4();\n        _this.styleOsm = new StyleOsm(_this.option);\n        _this.source = new VectorSource({ wrapX: false, url: _this.option.sourceUrl });\n        _this.vector = new VectorLayer({\n            //format: new GeoJSON(),\n            source: _this.source,\n            style: _this.styleOsm.styleFunction\n        });\n        _this.typles = Object.freeze({\n            NONE: Symbol('None'),\n            POLYGON: Symbol('Polygon'),\n            LINE: Symbol('LineString'),\n            POINT: Symbol('Point'),\n            CIRCLE: Symbol('Circle'),\n        });\n        _this.selectAltClick = new Select({\n            //@ts-ignored\n            condition: function (mapBrowserEvent) {\n                click(mapBrowserEvent);\n            },\n            filter: function () { return false; }\n        });\n        _this.type = _this.typles.POINT;\n        _this.draw = new Draw({\n            source: _this.source,\n            //@ts-ignored\n            type: _this.type.description\n        });\n        _this.initMap();\n        return _this;\n    }\n    /**\n     * Disposal of a map object\n     * @param callback callback function\n     */\n    BsrMap.prototype.Dispose = function (callback) {\n        var _a, _b;\n        if (!this.isDispose) {\n            this.isDispose = true;\n            this.map.getAllLayers().forEach(function (layer) {\n                var _a;\n                (_a = layer.getSource()) === null || _a === void 0 ? void 0 : _a.dispose();\n                layer.dispose();\n            });\n            this.map.getView().dispose();\n            this.map.dispose();\n            if (this.syncUnmount) {\n                this.syncUnmount();\n                this.syncUnmount = function () {\n                };\n            }\n            this.mapEventEntEdit.eventMap.clear();\n            this.mapEventCreated.eventMap.clear();\n            (_b = (_a = this.refDivMap.current) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(this.refDivMap.current);\n            if (callback)\n                callback();\n        }\n    };\n    BsrMap.prototype.initMap = function () {\n        var _this = this;\n        setTimeout(function () {\n            var _a, _b;\n            var coordinate = GetPosition(_this.option, _this.props.id);\n            _this.map = new Map$1({\n                interactions: defaults().extend([new Drag(_this, _this.option),]),\n                layers: [new TileLayer({\n                        source: new OSM(),\n                    }), _this.vector],\n                target: (_a = _this.props.id) !== null && _a !== void 0 ? _a : _this.id,\n                view: new View({\n                    projection: (_b = _this.option.projection) !== null && _b !== void 0 ? _b : 'EPSG:3857',\n                    center: coordinate.center,\n                    rotation: coordinate.rotation,\n                    zoom: coordinate.zoom,\n                }),\n            });\n            //this.map.addControl(new ZoomSlider());\n            if (_this.option.useSynchronizationUrl) {\n                // this.syncUnmount = SyncUrl(this.map, this.option,this.props.id)\n                _this.syncUnmount = new SyncUrl2(_this.map, _this.option, _this.props.id).Dispose;\n            }\n            if (_this.option.removeDoubleClickZoom) {\n                //     \n                _this.map.getInteractions().getArray().forEach(function (interaction) {\n                    if (interaction instanceof DoubleClickZoom) {\n                        _this.map.removeInteraction(interaction);\n                    }\n                });\n            }\n            //const link = new Link();\n            if (_this.option.onClick) {\n                _this.map.on(\"click\", function (evt) {\n                    var feature = _this.map.forEachFeatureAtPixel(evt.pixel, function (feature) {\n                        return feature;\n                    });\n                    if (feature) {\n                        _this.option.onClick(_this, feature, evt);\n                    }\n                    else {\n                        _this.option.onClick(_this, undefined, evt);\n                    }\n                });\n            }\n            if (_this.option.onShowContextMenu) {\n                _this.map.getViewport().addEventListener('contextmenu', function (e) {\n                    e.preventDefault();\n                    var pxl = _this.map.getEventPixel({ clientX: e.clientX, clientY: e.clientY });\n                    var feature = _this.map.forEachFeatureAtPixel(pxl, function (feature) {\n                        return feature;\n                    });\n                    _this.option.onShowContextMenu(_this, feature, e);\n                });\n            }\n            if (_this.option.useDrawBox) {\n                var dragBox_1 = new DragBox({\n                    condition: platformModifierKeyOnly,\n                    className: \"box-123\"\n                });\n                if (_this.option.onDrawBoxEnd) {\n                    dragBox_1.on('boxend', function () {\n                        var boxExtent = dragBox_1.getGeometry().getExtent();\n                        var boxFeatures = _this.source.getFeaturesInExtent(boxExtent);\n                        _this.option.onDrawBoxEnd(_this, boxFeatures, boxExtent);\n                    });\n                }\n                _this.map.addInteraction(dragBox_1);\n            }\n        });\n        if (this.props.featuresAsJson) {\n            this._addFeatureFromJson(this.props.featuresAsJson);\n        }\n        if (this.props.features) {\n            this.source.addFeatures(this.props.features);\n        }\n    };\n    /**\n     * Getting a div that contains a card\n     */\n    BsrMap.prototype.GetDivMap = function () {\n        return this.refDivMap.current;\n    };\n    /**\n     * Getting the current map projection\n     */\n    BsrMap.prototype.GetCurrentEPSGProjection = function () {\n        var _a;\n        return (_a = this.map) === null || _a === void 0 ? void 0 : _a.getView().getProjection().getCode();\n    };\n    /**\n     * Canceling a geometry creation operation\n     * @param callback callback function\n     */\n    BsrMap.prototype.CancelCreate = function (callback) {\n        this.map.removeInteraction(this.draw);\n        if (this.resolvePromise) {\n            this.resolvePromise();\n            this.isCreate = false;\n        }\n        if (callback)\n            callback();\n    };\n    /**\n     * Rotate the map\n     * @param rotation rotation magnitude\n     */\n    BsrMap.prototype.Rotation = function (rotation) {\n        var _a;\n        (_a = this.map) === null || _a === void 0 ? void 0 : _a.getView().setRotation(rotation);\n    };\n    BsrMap.prototype._addFeatureFromJson = function (json, callback) {\n        var format = new GeoJSON();\n        var features = format.readFeatures(json);\n        this.source.addFeatures(features);\n        if (callback)\n            callback();\n    };\n    /**\n     * Getting ol.VectorLayer\n     */\n    BsrMap.prototype.GetVectorLayer = function () {\n        return this.vector;\n    };\n    /**\n     * Getting ol.VectorSource\n     */\n    BsrMap.prototype.GetVectorSource = function () {\n        return this.source;\n    };\n    /**\n     * Getting ol.Map\n     */\n    BsrMap.prototype.GetMap = function () {\n        return this.map;\n    };\n    /**\n     * Redrawing Feature Styles\n     */\n    BsrMap.prototype.RefreshStyleFeatures = function () {\n        var _this = this;\n        this.source.getFeatures().forEach(function (f) {\n            f.setStyle(_this.styleOsm.styleFunction);\n        });\n    };\n    /**\n     * Overloading option styles is usually required if you have changed styles programmatically.\n     */\n    BsrMap.prototype.RefreshStyleSettings = function () {\n        this.styleOsm.refreshStyleSettings();\n    };\n    /**\n     * Redrawing feature styles into selected styles\n     * @param feature target Feature\n     */\n    BsrMap.prototype.SelectFeature = function (feature) {\n        var _a;\n        this.RefreshStyleFeatures();\n        feature.setStyle((_a = this.styleOsm) === null || _a === void 0 ? void 0 : _a.selectStyle());\n    };\n    /**\n     * Redrawing features styles into selected styles\n     * @param features target Features\n     */\n    BsrMap.prototype.SelectFeatures = function (features) {\n        var _this = this;\n        this.RefreshStyleFeatures();\n        features.forEach(function (f) {\n            var _a;\n            f.setStyle((_a = _this.styleOsm) === null || _a === void 0 ? void 0 : _a.selectStyle());\n        });\n    };\n    /**\n     * Redrawing a card to a new position\n     * @param center center map\n     * @param zoom zoom map\n     * @param rotation rotation map\n     */\n    BsrMap.prototype.GoTo = function (center, zoom, rotation) {\n        var view = this.map.getView();\n        view.setCenter(center);\n        if (zoom) {\n            view.setZoom(zoom);\n        }\n        if (rotation) {\n            view.setRotation(rotation);\n        }\n    };\n    /**\n     * Getting the current map display coordinates\n     */\n    BsrMap.prototype.GetMapCoordinate = function () {\n        var view = this.map.getView();\n        return {\n            center: view.getCenter(),\n            zoom: view.getZoom(),\n            rotation: view.getRotation()\n        };\n    };\n    /**\n     * Getting the coordinates of a square, displaying a map in a browser, can be obtained as an object or as a json string\n     * @param isJson request as json\n     */\n    BsrMap.prototype.GetBound = function (isJson) {\n        var extent = this.map.getView().calculateExtent(this.map.getSize());\n        var bound = {};\n        bound.p1 = [extent[0], extent[3]];\n        bound.p2 = [extent[2], extent[3]];\n        bound.p3 = [extent[2], extent[1]];\n        bound.p4 = [extent[0], extent[1]];\n        bound.p5 = [extent[0], extent[3]];\n        if (isJson) {\n            return JSON.stringify(bound);\n        }\n        return bound;\n    };\n    /**\n     * Getting features from a map, you can select the geometry type, when selecting undefined all features are selected\n     * @param geometry  'Point' | 'LineString' | 'Polygon' | 'Circle' | undefined\n     */\n    BsrMap.prototype.GetFeatures = function (geometry) {\n        switch (geometry) {\n            case undefined: {\n                return this.source.getFeatures();\n            }\n            case 'Point': {\n                return this.source.getFeatures().filter(function (f) {\n                    var _a;\n                    return ((_a = f.getGeometry()) === null || _a === void 0 ? void 0 : _a.getType()) === 'Point';\n                });\n            }\n            case 'LineString': {\n                return this.source.getFeatures().filter(function (f) {\n                    var _a;\n                    return ((_a = f.getGeometry()) === null || _a === void 0 ? void 0 : _a.getType()) === 'LineString';\n                });\n            }\n            case 'Polygon': {\n                return this.source.getFeatures().filter(function (f) {\n                    var _a;\n                    return ((_a = f.getGeometry()) === null || _a === void 0 ? void 0 : _a.getType()) === 'Polygon';\n                });\n            }\n            case 'Circle': {\n                return this.source.getFeatures().filter(function (f) {\n                    var _a;\n                    return ((_a = f.getGeometry()) === null || _a === void 0 ? void 0 : _a.getType()) === 'Circle';\n                });\n            }\n        }\n    };\n    /**\n     * Adding Features to a Map\n     */\n    BsrMap.prototype.AddFeatures = function (f) {\n        this.source.addFeatures(f);\n    };\n    /**\n     * Adding Feature to a Map\n     * @param data Feature or GeoJson as string\n     */\n    BsrMap.prototype.AddFeature = function (data) {\n        if (typeof data === \"string\") {\n            this._addFeatureFromJson(data);\n        }\n        else {\n            this.AddFeatures([data]);\n        }\n    };\n    /**\n     * Removing Feature from a Map\n     * @param f Feature to be removed\n     */\n    BsrMap.prototype.DeleteFeature = function (f) {\n        this.source.removeFeature(f);\n    };\n    /**\n     * Deleting all features from the map\n     * @param callback callback function\n     */\n    BsrMap.prototype.DeleteAllFeatures = function (callback) {\n        this.source.clear();\n        this.map.removeInteraction(this.draw);\n        if (this.resolvePromise) {\n            this.resolvePromise();\n        }\n        if (callback)\n            callback();\n    };\n    /**\n     * Getting the center of feature\n     */\n    BsrMap.prototype.GetCenterFeature = function (feature) {\n        return extent.getCenter(feature.getGeometry().getExtent());\n    };\n    /**\n     * Getting Feature Coordinates\n     */\n    BsrMap.prototype.GetCoordinateFeature = function (feature) {\n        var geometry = feature.getGeometry();\n        if (geometry instanceof SimpleGeometry) {\n            return geometry.getCoordinates();\n        }\n        else {\n            return [];\n        }\n    };\n    /**\n     * Getting  Feature flat Coordinates\n     */\n    BsrMap.prototype.GetFlatCoordinateFeature = function (feature) {\n        var geometry = feature.getGeometry();\n        if (geometry instanceof SimpleGeometry) {\n            return geometry.getFlatCoordinates();\n        }\n        else {\n            return [];\n        }\n    };\n    /**\n     * Getting options from props\n     */\n    BsrMap.prototype.GetOptions = function () {\n        return this.option;\n    };\n    /**\n     * remove last point when creating a feature\n     */\n    BsrMap.prototype.Undo = function () {\n        var _a;\n        (_a = this.draw) === null || _a === void 0 ? void 0 : _a.removeLastPoint();\n    };\n    /**\n     * Build, create feature\n     * @param geometry 'Polygon' | 'LineString' | 'Point' | 'Circle'\n     */\n    BsrMap.prototype.CreateFeature = function (geometry) {\n        var _this = this;\n        this.CancelCreate();\n        this.isCreate = true;\n        return new Promise(function (resolve, reject) {\n            try {\n                _this.mapEventCreated.eventMap.forEach(function (v) {\n                    v(true, undefined);\n                });\n                _this.map.removeInteraction(_this.selectAltClick);\n                _this.map.removeInteraction(_this.modify1);\n                _this.draw = new Draw({\n                    source: _this.source,\n                    //@ts-ignored\n                    type: geometry\n                });\n                _this.resolvePromise = function () {\n                    _this.mapEventCreated.eventMap.forEach(function (v) {\n                        v(false, undefined);\n                    });\n                    _this.resolvePromise = undefined;\n                    resolve({\n                        bsrMap: _this,\n                        isCancel: true,\n                        feature: undefined,\n                        geometry: geometry,\n                    });\n                };\n                _this.draw.on('drawend', function (e) {\n                    _this.resolvePromise = undefined;\n                    var feature = e.feature;\n                    _this.map.removeInteraction(_this.draw);\n                    _this.isCreate = false;\n                    if (_this.option.onDrawEnd) {\n                        _this.option.onDrawEnd(_this, feature);\n                    }\n                    // this.editOnlyRouteOrPolygon()\n                    resolve({\n                        bsrMap: _this,\n                        isCancel: false,\n                        feature: feature,\n                        geometry: geometry,\n                    });\n                    setTimeout(function () {\n                        _this.mapEventCreated.eventMap.forEach(function (v) {\n                            v(false, feature);\n                        });\n                    });\n                });\n                _this.map.addInteraction(_this.draw);\n            }\n            catch (e) {\n                _this.isCreate = false;\n                reject(e);\n                setTimeout(function () {\n                    _this.mapEventCreated.eventMap.forEach(function (v) {\n                        v(false, undefined);\n                    });\n                });\n            }\n        });\n    };\n    /**\n     * start edit feature\n     * @param feature Feature<Geometry>\n     * @param callback callback function\n     */\n    BsrMap.prototype.StartEditFeature = function (feature, callback) {\n        var _this = this;\n        this.editFeature = feature;\n        this.mapEventEntEdit.eventMap.forEach(function (s) {\n            s(true, _this.editFeature);\n        });\n        var d = this.selectAltClick.getFeatures();\n        if (d.getLength() > 0) {\n            this.selectAltClick.getFeatures().clear();\n        }\n        else {\n            this.selectAltClick.getFeatures().push(feature);\n            this.editOnlyRouteOrPolygon();\n        }\n        this.isEdit = true;\n        if (callback)\n            callback();\n    };\n    Object.defineProperty(BsrMap.prototype, \"IsEdit\", {\n        /**\n         * Get the map state, whether the map is in geometry editing state\n         */\n        get: function () {\n            return this.isEdit;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BsrMap.prototype, \"IsCreate\", {\n        /**\n         * Get the state of the map, whether the map is in the state of creating geometry\n         */\n        get: function () {\n            return this.isCreate;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Subscribe to feature edit events, returns a key that can be used to unsubscribe\n     */\n    BsrMap.prototype.AddEvenStateEditingFeature = function (fun) {\n        var key = v4();\n        this.mapEventEntEdit.eventMap.set(key, fun);\n        return key;\n    };\n    /**\n     * Unsubscribing to Feature Editing Events\n     * @param key event key\n     */\n    BsrMap.prototype.RemoveEvenStateEditingFeature = function (key) {\n        this.mapEventEntEdit.eventMap.delete(key);\n    };\n    /**\n     * Subscribe to feature creation events, returns a key that can be used to unsubscribe\n     */\n    BsrMap.prototype.AddEventStateCreatingFeature = function (fun) {\n        var key = v4();\n        this.mapEventCreated.eventMap.set(key, fun);\n        return key;\n    };\n    /**\n     * Unsubscribing to geometry creation events\n     * @param key event key\n     */\n    BsrMap.prototype.RemoveEventStateCreatingFeature = function (key) {\n        this.mapEventCreated.eventMap.delete(key);\n    };\n    /**\n     * end of editing feature\n     */\n    BsrMap.prototype.EndEditFeature = function (callback) {\n        var _this = this;\n        this.selectAltClick.getFeatures().clear();\n        this.isEdit = false;\n        this.mapEventEntEdit.eventMap.forEach(function (s) {\n            s(false, _this.editFeature);\n        });\n        if (callback) {\n            callback();\n        }\n        this.editFeature = undefined;\n    };\n    /**\n     * Transforming Feature into  geo json\n     */\n    BsrMap.prototype.FeatureToJson = function (f) {\n        var geoJsonGeom = new GeoJSON();\n        var featureClone = f.clone();\n        return geoJsonGeom.writeGeometry(featureClone.getGeometry());\n    };\n    /**\n     * Transforming Feature into  geo json collection\n     */\n    BsrMap.prototype.FeaturesToJson = function (features) {\n        var geoJsonGeom = new GeoJSON();\n        return geoJsonGeom.writeFeatures(features);\n    };\n    BsrMap.prototype.editOnlyRouteOrPolygon = function () {\n        var _this = this;\n        this.modify1 = new Modify({\n            features: this.selectAltClick.getFeatures()\n        });\n        if (this.option.onModifyEnd) {\n            this.modify1.on('modifyend', function (event) {\n                event.features.forEach(function (feature) {\n                    _this.option.onModifyEnd(_this, feature);\n                });\n            });\n        }\n        this.map.addInteraction(this.modify1);\n        this.map.addInteraction(this.selectAltClick);\n    };\n    /**\n     * Redrawing features styles\n     */\n    BsrMap.prototype.RefreshStyleFeature = function (feature) {\n        feature.setStyle(this.styleOsm.styleFunction(feature));\n    };\n    BsrMap.prototype.componentWillUnmount = function () {\n        if (this.isDispose)\n            return;\n        if (this.syncUnmount) {\n            this.syncUnmount();\n        }\n    };\n    BsrMap.prototype.componentDidMount = function () {\n        this.mapEventEntEdit.eventMap.clear();\n        this.mapEventCreated.eventMap.clear();\n    };\n    BsrMap.prototype.render = function () {\n        var _a, _b;\n        return (React.createElement(\"div\", { ref: this.refDivMap, className: (_a = this.props.className) !== null && _a !== void 0 ? _a : 'bsr-map-default', style: this.props.style, id: (_b = this.props.id) !== null && _b !== void 0 ? _b : this.id }));\n    };\n    return BsrMap;\n}(React.Component));\n\nvar ContextMenuMap = /** @class */ (function (_super) {\n    __extends(ContextMenuMap, _super);\n    function ContextMenuMap(props) {\n        return _super.call(this, props) || this;\n    }\n    ContextMenuMap.prototype.render = function () {\n        var _this = this;\n        return (React.createElement(\"div\", { onClick: function () { _this.props.actionClose(); } }, this.props.element));\n    };\n    return ContextMenuMap;\n}(React.Component));\nfunction ProxyMenuDialog(evt, element) {\n    var div = document.createElement(\"div\");\n    div.setAttribute(\"id\", \"12-23\");\n    div.className = \"bsr-map-context-menu\";\n    div.style.top = evt.pageY + \"px\";\n    div.style.left = evt.pageX + \"px\";\n    div.onmousedown = function (e) {\n        e.stopPropagation();\n        e.preventDefault();\n    };\n    var innerRoot = createRoot(div);\n    function close() {\n        innerRoot.render(null);\n        document.body.removeChild(div);\n        document.removeEventListener(\"mousedown\", close);\n    }\n    document.addEventListener(\"mousedown\", close);\n    document.body.appendChild(div);\n    innerRoot.render(React.createElement(ContextMenuMap, { element: element, actionClose: close }));\n}\n\nexport { BsrMap, ProxyMenuDialog };\n"],"names":["SelectEventType","SelectEvent","Event","constructor","type","selected","deselected","mapBrowserEvent","super","this","originalFeatureStyles","Select","Interaction","options","layerFilter","on","once","un","boundAddFeature_","addFeature_","bind","boundRemoveFeature_","removeFeature_","condition_","condition","singleClick","addCondition_","addCondition","never","removeCondition_","removeCondition","toggleCondition_","toggleCondition","shiftKeyOnly","multi_","multi","filter_","filter","TRUE","hitTolerance_","hitTolerance","style_","undefined","style","styles","createEditingStyle","extend","feature","getGeometry","getType","getDefaultStyleFunction","features_","features","Collection","layers","layer","includes","layerFilter_","featureLayerAssociation_","addFeatureLayerAssociation_","getUid","getFeatures","getHitTolerance","getLayer","setHitTolerance","setMap","map","getMap","forEach","restorePreviousStyle_","addEventListener","CollectionEventType","ADD","REMOVE","applySelectedStyle_","removeEventListener","evt","element","getAllLayers","find","VectorLayer","getSource","hasFeature","getStyle","key","setStyle","interactions","getInteractions","getArray","i","length","interaction","lastIndexOf","removeFeatureLayerAssociation_","handleEvent","add","remove","toggle","set","clear","forEachFeatureAtPixel","pixel","Feature","push","getLength","item","index","indexOf","splice","j","dispatchEvent","Circle","SimpleGeometry","center","radius","layout","setFlatCoordinates","setCenterAndRadius","clone","circle","flatCoordinates","slice","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","dx","dy","squaredDistance","stride","delta","getRadius","Math","sqrt","containsXY","getRadiusSquared_","getCenter","computeExtent","extent","createOrUpdate","intersectsExtent","circleExtent","getExtent","intersects","forEachCorner","intersectsCoordinate","setCenter","changed","setLayout","offset","deflateCoordinate","ii","getCoordinates","setCoordinates","coordinates","setRadius","rotate","angle","anchor","getStride","prototype","transform","DrawEventType","DrawEvent","getSquaredDistance","a","b","getCoordinate","count","getCumulativeSquaredDistance","startIndex","endIndex","lowIndex","highIndex","lowWholeIndex","ceil","highWholeIndex","floor","interpolateCoordinate","sd","appendGeometryTraceTargets","coordinate","geometry","targets","LineString","appendTraceTarget","MultiLineString","Polygon","MultiPolygon","polys","jj","GeometryCollection","geometries","getGeometries","sharedUpdateInfo","NaN","ring","rel","getPointSegmentRelationship","along","sharedRel","start","end","x1","y1","px","py","clamp","toFixed","x0","y0","Draw","PointerInteraction","pointerOptions","stopDown","FALSE","shouldHandle_","downPx_","downTimeout_","lastDragTime_","pointerType_","freehand_","source_","source","snapTolerance_","snapTolerance","type_","mode_","Error","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","maxPoints","Infinity","finishCondition_","finishCondition","geometryLayout_","geometryLayout","geometryFunction","mode","projection","fromUserCoordinate","squaredLength","squaredCoordinateDistance","userProjection","getUserProjection","Constructor","Point","concat","geometryFunction_","dragVertexDelay_","dragVertexDelay","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","squaredClickTolerance_","clickTolerance","overlay_","VectorSource","useSpatialIndex","wrapX","updateWhileInteracting","geometryName_","geometryName","noModifierKeys","freehandCondition_","freehand","always","freehandCondition","traceCondition_","setTrace","trace","traceState_","active","traceSource_","traceSource","addChangeListener","InteractionProperty","ACTIVE","updateState_","getOverlay","event","originalEvent","EventType","CONTEXTMENU","preventDefault","move","MapBrowserEventType","POINTERMOVE","pass","POINTERDRAG","Date","now","clearTimeout","addToDrawing_","POINTERDOWN","getPointerCount","handlePointerMove_","pointerType","DBLCLICK","handleDownEvent","startDrawing_","setTimeout","MapBrowserEvent","frameState","deactivateTrace_","toggleTraceState_","lowerLeft","getCoordinateFromPixel","upperRight","boundingExtent","getFeaturesInExtent","getTraceTargets","startPx","targetIndex","addOrRemoveTracedCoordinates_","target","previouslyForward","addTracedCoordinates_","removeTracedCoordinates_","fromIndex","toIndex","removeLastPoints_","appendCoordinates","updateTrace_","traceState","distance","updatedTraceTarget","closestTargetDistance","newTargetIndex","newEndIndex","minSegmentDistance","coordinateIndex","newTarget","considerBothDirections","newCoordinate","getPixelFromCoordinate","forwardDistance","reverseDistance","getTraceTargetUpdate","oldTarget","round","handleUpEvent","tracing","startingToDraw","finishDrawing","atFinish_","abortDrawing","downPx","clickPx","modifyDrawing_","createOrUpdateSketchPoint_","at","potentiallyDone","potentiallyFinishCoordinates","sketchCoords","finishCoordinate","finishPixel","updateSketchFeatures_","createOrUpdateCustomSketchLine_","getLinearRing","sketchLineGeom","getLayout","getFlatCoordinates","setGeometry","getView","getProjection","getStrideForLayout","setGeometryName","last","done","pop","n","removeLastPoint","sketchFeature","abortDrawing_","MultiPoint","addFeature","newDrawing","shift","ending","lineString","sketchFeatures","overlaySource","addFeatures","getActive","resolution","tempExtent","tempSegment","ModifyEventType","ModifyEvent","Modify","boundHandleFeatureChange_","handleFeatureChange_","primaryAction","defaultDeleteCondition_","altKeyOnly","deleteCondition_","deleteCondition","insertVertexCondition_","insertVertexCondition","vertexFeature_","vertexSegments_","lastPixel_","ignoreNextSingleClick_","featuresBeingModified_","rBush_","RBush","pixelTolerance_","pixelTolerance","snappedToVertex_","changingFeature_","dragSegments_","updateWhileAnimating","SEGMENT_WRITERS_","writePointGeometry_","writeLineStringGeometry_","writePolygonGeometry_","writeMultiPointGeometry_","writeMultiLineStringGeometry_","writeMultiPolygonGeometry_","writeCircleGeometry_","writeGeometryCollectionGeometry_","hitDetection_","VectorEventType","ADDFEATURE","handleSourceAdd_","REMOVEFEATURE","handleSourceRemove_","hitDetection","handleFeatureAdd_","handleFeatureRemove_","lastPointerEvent_","delta_","snapToPointer_","snapToPointer","writer","isRendered","handlePointerAtPixel_","CHANGE","willModifyFeatures_","segments","segment","s","ss","removeFeatureSegmentData_","removeFeature","rBush","nodesToRemove","node","nodeToRemove","setActive","segmentData","insert","points","depth","lines","rings","polygons","k","kk","centerSegmentData","circumferenceSegmentData","featureSegments","createExtent","circleGeometry","fromCircle","getGeometriesArray","createOrUpdateVertexFeature_","vertexFeature","handled","getInteracting","handlingDownUpSequence","SINGLECLICK","removePoint","handleDragEvent","vertex","dragSegment","coordinateDistance","setGeometryCoordinates_","pixelCoordinate","insertVertices","vertexExtent","segmentDataMatches","getInExtent","componentSegments","sort","compareIndexes","segmentDataMatch","uid","join","Array","coordinatesEqual","closestVertex","closestOnSegmentData","insertVertex_","update","sortByDistance","projectedDistanceToSegmentDataSquared","nodes","hitPointGeometry","toUserCoordinate","geom","viewExtent","fromUserExtent","buffer","getResolution","box","toUserExtent","bufferExtent","closestSegment","vertexPixel","dist","vertexSegments","pixel1","pixel2","squaredDist1","squaredDist2","min","geometryUid","rTree","updateSegmentIndices_","newSegmentData","newSegmentData2","removed","removeVertex_","dragSegments","segmentsByFeature","component","left","newIndex","right","deleted","forEachInExtent","equals","pointCoordinates","distanceToCenterSquared","distanceToCircumference","squaredDistanceToSegment","getClosestPoint","closestOnSegment","extendStatics","d","Object","setPrototypeOf","__proto__","p","hasOwnProperty","call","__extends","TypeError","String","__","create","SuppressedError","getRandomValues","byteToHex","toString","rnds8","Uint8Array","rng","crypto","native","randomUUID","v4","buf","rnds","random","arr","arguments","toLowerCase","unsafeStringify","_evt$activePointers$","_evt$activePointers$2","activePointers","shiftKey","ctrlKey","coordinate_","feature_","deltaX","deltaY","translate","drag_","option","onDragEnd","bsrMap","handleMoveEvent","cursor_","getTargetElement","cursor","previousCursor_","Drag","Pointer","StyleOsm","_defineProperty","stylesSelect","refreshStyleSettings","_this$option$style$fi","_this$option$style","_this$option$style$co","_this$option$style2","_this$option$style$wi","_this$option$style3","_this$option$style$ra","_this$option$style4","_this$option$style$co2","_this$option$style5","_this$option$style$co3","_this$option$style6","_this$option$style$wi2","_this$option$style7","_this$option$style$fi2","_this$option$style8","_this$option$style$co4","_this$option$style9","_this$option$style$wi3","_this$option$style10","_this$option$style$fi3","_this$option$style11","_this$option$style$co5","_this$option$style12","_this$option$style$wi4","_this$option$style13","_this$option$style$ra2","_this$option$style14","_this$option$style$co6","_this$option$style15","Style","fill","Fill","color","hexToRgbAEx","fillBodySelect","stroke","Stroke","colorLineSelect","width","widthLineSelect","image","radiusPointSelect","colorPointSelect","colorLineString","widthLineString","fillPolygon","colorPolygon","widthPolygon","fillCircle","colorCircle","widthCircle","radiusPoint","colorPoint","hex","c","test","substring","split","parse","hash","parts","zoom","parseFloat","rotation","GetPosition","id","_a","_b","_c","_d","useSynchronizationUrl","tag","URLSearchParams","window","location","get","res","hashMap","name","matches","document","cookie","match","RegExp","replace","decodeURIComponent","getCookie","MapEventEditing","eventMap","Map","MapEventCreated","shouldUpdate","SyncUrl2","_this","popState","view","setZoom","setRotation","state","getZoom","getRotation","history","replaceState","getHashCore","hashNew","str","iaAppendMap","value","updatePermalink","pushState","pp23","Dispose","BsrMap","_super","props","mapEventEntEdit","mapEventCreated","isEdit","isCreate","isDispose","refDivMap","React","styleOsm","url","sourceUrl","vector","styleFunction","typles","freeze","NONE","Symbol","POLYGON","LINE","POINT","CIRCLE","selectAltClick","click","draw","description","initMap","callback","dispose","syncUnmount","current","parentNode","removeChild","Map$1","defaults","TileLayer","OSM","View","removeDoubleClickZoom","DoubleClickZoom","removeInteraction","onClick","onShowContextMenu","getViewport","e","pxl","getEventPixel","clientX","clientY","useDrawBox","dragBox_1","DragBox","platformModifierKeyOnly","className","onDrawBoxEnd","boxExtent","boxFeatures","addInteraction","featuresAsJson","_addFeatureFromJson","GetDivMap","GetCurrentEPSGProjection","getCode","CancelCreate","resolvePromise","Rotation","json","GeoJSON","readFeatures","GetVectorLayer","GetVectorSource","GetMap","RefreshStyleFeatures","f","RefreshStyleSettings","SelectFeature","selectStyle","SelectFeatures","GoTo","GetMapCoordinate","GetBound","isJson","calculateExtent","getSize","bound","p1","p2","p3","p4","p5","JSON","stringify","GetFeatures","AddFeatures","AddFeature","data","DeleteFeature","DeleteAllFeatures","GetCenterFeature","GetCoordinateFeature","GetFlatCoordinateFeature","GetOptions","Undo","CreateFeature","Promise","resolve","reject","v","modify1","isCancel","onDrawEnd","StartEditFeature","editFeature","editOnlyRouteOrPolygon","defineProperty","enumerable","configurable","AddEvenStateEditingFeature","fun","RemoveEvenStateEditingFeature","delete","AddEventStateCreatingFeature","RemoveEventStateCreatingFeature","EndEditFeature","FeatureToJson","geoJsonGeom","featureClone","writeGeometry","FeaturesToJson","writeFeatures","onModifyEnd","RefreshStyleFeature","componentWillUnmount","componentDidMount","render","ref","ContextMenuMap","actionClose","ProxyMenuDialog","div","createElement","setAttribute","top","pageY","pageX","onmousedown","stopPropagation","innerRoot","createRoot","close","body","appendChild"],"sourceRoot":""}